# 15 주차 과제 정리

### **Project Structure 란?**

→ 프로젝트을 관리하기 위해 파일과 폴더를 어떤 구조로 만들지 구상하는것을 뜻함

- 올바른 Project Structure 는 유지보수성 확장성, 협업성을 높여줄수 있습니다.
- MVC 패턴은 병렬 개발하는데 도움을 준다.
    - MVC 패턴이란
        
        Model - View - Controller 의 약자로 소프트웨어를 구성하는 세 가지 구성요소에 따라 분리하여 설계하는것을 뜻함.
        
        - Model
            - 데이터와 데이터처리 로직을 담당합니다. (데이터 베이스 관련)
            - 데이터 유효성 검사, 처리 방법 등등등 …
        - View
            - UI(사용자 인터페이스)를 담당합니다.
            - 데이터를 시각적으로 표현하며, 사용자와의 상호작용(사용자에게 정보를 보여주거나, 입력을 받는 것)을 담당한다.
        - Controller
            - 모델과 뷰 사이의 중간 매개체 역할로써
            - 사용자의 입력을 받아 해당 업데이트가 필요한곳에 전달해준다.(모델을 업데이트하냐, 뷰를 업데이트 하냐)
        - 장점
            - 명확하게 역할을 분담하여 유지 보수성을 높이고, 코드 재사용성을 증가시킬 수 있다.
            - 소프트웨어 각 부분을 독립적으로 개발하고 테스트 할 수 있어서 개발 생산성(신속도, 정확도)을 높이는데 도움을 줍니다.
        
- 예시
    - 파일 규칙
        - controllers : app route handlers 와 business logic(비즈니스 로직)
            - business logic : 어떠한 비즈니스의 요구사항을 충족시키기 위한 데이터처리나 규칙의 관련된 핵심적인 로직들
        - util : 유틸함수들 (모든곳에서 사용되는 함수)
        - middlewares : 미들웨어들
        - models : 컨트롤러와 데이터베이스 사이 스키마를 정의하고 몇 가지 유효성 검사를 하는 곳
        - routes : HTTP 메서드를 사용하여 앱 경로를 정의하는 곳
        - public : 정적이미지, 사용자 정의, javaScript 파일, CSS 파일 등등 저장합니다.
        - views : 서버에서 렌더링할 템플릿을 포함합니다. ——→ ejs 파일 같은 것들?
        - test : 모든 단위 테스트, 수락 테스트 작성하는 곳
        - app.js : 프로젝트의 메인 파일 역할을 한다.
        - package.json : 실행할 스크립트 및 프로젝트 버젼을 관리해줍니다.
            
            
    - 콜백함수 보다 프로미스를 사용해라
    - try catch 문을 사용해라
    - 동기적인 코드 사용을 지양해라
    - logging(로깅)(console.log, console.error) 을 적절히 사용해라
    - debug 같은 모듈을 사용해서 console.err() 로 전송되는 디버그 메세지를 제어해라
    - 데이터 베이스에 기록해라 —> 몽구스 플러그인, Winston, Bunyan 추천
    - __dirname 을 사용해서 .././../.././../ 을 최대한 줄여라
    - NODE_ENV 를 production 으로 설정해라
    - 프로세스 매니져를 사용해라 —> StrongLoop Processs Manager, PM2, Foerver
    - 클러스터를 사용해라
    - pm2 를 사용해라
- Monolith 구조
    
    → 한 프로젝트에서 하나의 소프트웨어를 구성하는 모든 모듈과 코드를 관리하는 것을 말한다.
    
    - 애플리케이션 가동하기 위해 하나의 단일 프로젝트만 실행시키면 된다.
        
        ```jsx
        app/                            // 모든 모듈과 코드가 app 폴더에 존재
        	  domain/
        		    users/
        			      model.py
        			      repository.py
        		    products/
        			      model.py
        			      repository.py
        		    payment/
        			      model.py
        			      repository.py
        	  service/
        		    user_service.py
        		    product_service.py
        		    payment_service.py
        	  controller/
        		    user_controller.py
        		    product_controller.py
        		    payment_controller.py
        	  main.py
        	  config.json
        ```
        
    - 장점
        - 한 프로젝트 내에 모든 모듈과 코드가 있으므로 개발이 간단하고 리뷰가 용이하다.
        - 구조가 단순해서 애플리케이션 전체 구조가 보기 편하다.
        - 배포하는데 있어서 하나만 구동하면 되기 때문에 배포하기 쉽다.
        - 디버깅이나 에러처리 하는데 있어서 장애 처리하기 쉽다.
    - 단점
        - 코드가 많아짐에 따라 장점인 전체 구조 파악이 담점이 돼서 전체 구조 파악과 코드 흐름을 이해하기 어렵다
        - 모든 코드가 하나의 파일 아래 결합되어 있어서 수정과 확장이 어렵다.
        - 새로운 사람이 투입돼서 개발한다고 하면 전체 코드를 파악해야 코드를 쓸 수 있고 수정 확장이 어려워서 개발적 속도가 느려질 수 있다.
        - 테스트 또한 모든 코드의 대해서 실행해야 하므로 점점 느려질 수 있다.
        - 최신 기술이 나와도 모든 코드에 영향이 가기 때문에 섣불리 적용하기 어렵다.

### vs

- **Microservices 구조**
    
    → 하나의 소프트웨어를 구성하는 컴포넌트들을 독립적인 프로젝트들로 분리해서 관리하는 것을 말한다.
    
    - 각각의 컴포넌트들을 마이크로 서비스라 부른다.
    - 개발과 배포도 마이크로 서비스 단위로 이루어진다.
    - 하나의 소프트웨어(애플리케이션)이 동작하려면 각각을 구성하는 마이크로서비스들이 모두 정상 작동해야 합니다.
    
    ```jsx
    # Users
    app/
      domain/
        model.py
      service/
        user_service.py
      controller/
        user_controller.py
      main.py
      config.json
    ```
    
    ```jsx
    # Products
    app/
      domain/
        model.py
      service/
        product_service.py
      controller/
        product_controller.py
      main.py
      config.json
    ```
    
    ```jsx
    # Payment
    app/
      domain/
        model.py
      service/
        payment_service.py
      controller/
        payment_controller.py
      main.py
      config.json
    ```
    
    - 위에 3개의 마이크로서비스들은 HTTP 통신으로 협력 한다.
    - 장점
        - 각 마이크로 서비스도 작은 규모이기 때문에 모놀리스 장점 처럼 전체구조를 파악하기 쉽다.
        - 전체적으로 분리되어 있어서 결합도가 낮다.
        - 그에 따른 수정이나 확장역시 용이하고 개발 속도도 빠르다.
        - 테스트 또한 각각의 마이크로 서비스에 대해서만 실행하면 되기 때문에 속도가 빠르다.
        - 마이크로서비스별 컴퓨팅 리소스, 서버 개수, 개발 스택등을 각각 마다 다르게 줄 수 있다.
    - 단점
        - 각 서비스가 분산되어 있어서 전체 애플리케이션에 대해 테스트 할 때 난이도가 높아진다.
        - 처음 나누는 기준을 잡기 힘들다.
        - 잘못 나눌경우 나중에 대공사를 해야할 수 있다.
        - 각 팀당 자기가 맡은 서비스의 관해서만 관리하다보면 개발자 개개인이 전체구조를 파악하기 어렵다.
        - 전체구조를 파악하기 어렵기때문에 또 추가적인 비용이나 자원이 소모된다.

### passport 모듈

→ 로그인 절차를 확실하게 하기위해 사용되는 라이브러리처럼 클라이언트 자격을 인증해주는 미들웨어

- 일련의 흐름
    1. 로그인 요청이 들어온다.
    2. 해당 라우터 미들웨어 내부에서 passport.authenticate()을 호출한다. 
    3. 해당 passport.authenticate() 이 호출 되면 passport/localStrategy.js 가 호출 돼서
    4. passport/localStrategy.js 미들웨어 내부에 passport.use(객체, 미들웨어)를 사용해줍니다.
    5. passport.use 의 미들웨어 내부에서 done() 을 사용하여 종료시킬 수 있는데 전달하는 매개변수의 따라 행동이 달라진다.
        - done (null, 유저 data) —> 로그인 성공한것을 의미
        - done (null, false, { message : “~~~~~”); —> 로그인이 실패한것을 의미 한다.
        - done (error)  —> 로그인중 에러가 발생한 것을 의미한다.
    6. passport.use 의 미들웨어 내부에서 done() 을 사용하면 passport.authenticate()의 다음 미들웨어가 호출 된다.
    7. 해당 미들웨어에서 매개변수를 받는데 각각 위에 done에서 던져준 인수들을 받아줍니다.
    8. 로그인이 성공시 req.login(user, 에러처리 미들웨어)로 넣어줍니다.
    9. req.login 메서드가 passport.serializeUser() 를 호출이 돼서 passport.serializeUser() 내부적으로 done 을 호출하면
    10. passport.deserializeUser() 에서 req.session 에 유저 ID를 저장을 해줌.
    11. passport.deserializeUser() 내부 미들웨어 에서 또 done을 이용해서 다음 행동을 이어가줍니다.
        - done (null, user) : req.login 다음 미들웨어 호출하고 인자로 던져 줍니다.
        - done (error) : req.login 다음 미들웨어 호출하고 인자로 던져 줍니다.
    12. 
- 사용자 인증/인가 방식
    
    ### 인증, 인가란 ?
    
    - 인증 : 사용자의 신원을 검증하는 하는것을 뜻함
    - 인가 : 인증이후 인증된 사용자가 어떠한 자원에 접근할 수 있는지 확인하는 절차
    
    HTTP stateless 특성 : HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는다.
    
    - stateful vs stateless 차이
        
        ### Stateful (상태유지)
        
        - 서버가 클라이언트의 상태를 보존(기억)하는 것을 뜻함
            - 서버에서 클라이언트 이전 단계에서 제공한 값을 저장하고, 다음 단계에서도 저장한 상태(로그인하고, 다시 나갔다와도 로그인 상태유지)
            - 이러한 정보들을 브라우져의 쿠키, 서버의 세션 메모리에 저장된다.
        - stateful 프로토콜 예시 — TCP의 3-way handshaking
            
            → TCP는 세션 상태에 따라 서버의 응답이 달라지게 되므로 stateful 하다고 말할 수 있다. 
            
            ![Untitled](15%20%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2023de31da87ab4978b64bb0d7ba3d1466/Untitled.png)
            
        
        ### Stateful 단점
        
        - 상태를 저장하고 있는 해당 서버에서 다른 서버로 옮기게 될 경우 문제가 발생할 수 있다.
            - 새로운 서버엔 기존 정보가 없으므로 처음부터 다시 저장해야하는 문제가 발생할 수 있다.
                
                → 보통 캐시 서버에 저장하여 이용
                
        
        ## stateless (무상태)
        
        → 서버가 클라이언트의 상태를 보존하지 않음을 의미합니다.
        
        - 단순히 요청이 오면 응답을 보내는 역할만 수행한다.
        - 대표적인 stateless 예시로 UDP 와 HTTP 를 들 수 있다.
        - 통신에 필요한 모든 상태들을 클라이언트에서 가지고 있다가 서버와 통신할때 데이터에 실어 보내는 구조
            
            ![Untitled](15%20%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2023de31da87ab4978b64bb0d7ba3d1466/Untitled%201.png)
            
        
        ## stateless 장점
        
        - 대량의 트래픽이 발생해도 서버 확장을 쉽게 할 수 있어서 대처를 수월하게 할 수 있다.
        
        ## stateless 단점
        
        - stateful 보다 클라이언트 측에 더 많은 데이터가 소모되게 된다.
    
    ### 인증, 인가 구별 방법
    
    - 쿠키(Cookie)
        
        → 웹 서버가 생성하여 웹 브라우저로 전송 하는 작은 정보 파일을 뜻합니다
        
        - HTTP 프로토콜이 Stateless 한 속성을 가지고 있기 때문에 서버와 클라이언트 간 연결을 유지하기 위해 식별 데이터로써 만들어졌다.
        - key, value 형태로 데이터가 저장이 되고, 경로, 유효기간 같은 설정 정보들이 저장되어 있다.
        - 웹 브라우저는 수신한 쿠키를 정해진 기간동안 또는 웹사이트에서의 사용자 세션 기간 동안 저장합니다.
        - 웹 브라우저는 나중에 사용자가 웹 서버에 요청할 때 저장해 놓았다가 관련된 쿠키를 같이 보내줍니다.
            
            ![Untitled](15%20%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2023de31da87ab4978b64bb0d7ba3d1466/Untitled%202.png)
            
        
        ### 쿠키가 저장되는 장소 :  웹브라우저가 사용자 기기의 지정된 파일에 저장시켜줍니다.
        
        ### 쿠키 사용 용도
        
        - 웹 사이트 활동에서 특정 사용자와 연결하는데 도움을 준다. (세션 쿠키)
            - 세션쿠키
                - 웹 사이트에서 사용자의 세션을 추척하는데 도움을 줍니다
                - 사용자 세션과 해당 사용자의 관련 데이터, 콘텐츠를 나타내는 고유 문자열이 포함되어 있습니다.
                - 로그인시 세션 쿠키가 해당 웹사이트 서버에서 생성되어 브라우저로 전송된다.
                - 사이트 내에서 여러 서비스를 이용할시 웹사이트(서버)로 요청을 보내면 해당 요청에 쿠키가 담겨 있어서 특정 사용자로 인식해서 다시 로그인할 필요를 없애줍니다.
                - 만료일이 존재하지 않는다.
                - 세션이 종료되면 같이 삭제되어 브라우져에 알려준다.
        - 개인화에 도움을 준다 —> 쿠키내부에 사용자 행동, 사용자의 기본 설정이 “기억” 되므로 웹사이트에서 사용자 경험에따라 맞춤으로 정보를 제공할수 있다.
        - 일부 쿠키에서는 다른 웹사이트를 방문한 것도 기록됩니다.
            
            —> 추적 쿠키라고 해서 추적 쿠키를 사용하는 웹사이트를 방문 했을시 해당 웹사이트가 아닌 다른 웹사이트로 이동을 해도 해당 쿠키에 기록될 수 있습니다.
            
            - 추적 쿠키
                - 추적 서비스에서 생성되어서 사용자의 활동을 기록합니다.
                - 브라우저는 해당 사이트가 아닌 다른 웹 사이트를 로드 또는 활동 할때 관련 기록을 해당 추적 서비스로 전송합니다.
        
        ### 여러가지 쿠키 유형
        
        - 세션 쿠키 : 웹 사이트에서 사용자의 세션을 추적하는 데 도움을 준다.
        - 인증 쿠키
            - 세션쿠키가 될 수도 있고 영구 쿠키가 될 수도 있지만 일반적으로는 영구쿠키로 설정
            - 이름 그대로 인증을 해주는 쿠키여서 사용자의 인증 상태를 지속적으로 확인해서 로그인 상태를 유지합니다.
        - 영구 쿠키 : 세션 쿠키와 달리 정해진 기간동안 사용자 브라우저에 남아 있는다.(만료일이 꼭 있어야 한다)
            - 사이트를 다시 나갔다 돌아와도 로그인 상태 유지에 도움을 줍니다. (Remember Me 기능과 관련)
            - 사용자 식별 정보, 세션 토큰을 포함합니다.
        - 추적 쿠키 : 추적 서비스에서 생성되어서 사용자의 활동을 서비스로 보내줍니다. (타사 쿠키)
        - 좀비 쿠키
            - 다른 쿠키들과 다르게 삭제된 이후 다시 자동으로 다시 생성된다.
            - 일반적인 쿠키가 저장되는 외부에 자신의 백업을 생성합니다.
            - 세션 쿠키를 사용자가 삭제했을시 다시 사용자를 기억하는데 사용될 수도 있지만
            - 악의적으로 부적절한 광고를 계속 띄워줄도 있고, 이 쿠키를 이용해서 악성코드 설치나 해킹시도를 할 수 있습니다.
            - 추가로 사용자가 삭제해도 다시 생성되기 때문에 프라이버시 침해를 당할 수 있고 웹사이트와의 신뢰가 손상 될 수 있습니다.
    - 세션(Session)
        
        

### 헷갈리는 질문들

- 몽구스에서 스키마를 만든이유?
    
    -> SQL(MySQL) 사용자가 NoSQL(MongoDB, Redis)에 테이블이 없기 때문에 데이터를 검사해서 넣고자 만들어졌다.
    
    - 테이블과 비슷한 역할을 해주고 기준에 어긋나는 데이터들은 에러를 발생시켜준다.
    
- 관계형 데이터베이스(SQL) vs 비관계형 데이터베이스(NoSQL)
    - 관계형 데이터 베이스
        - 데이터를 행과 열이 있는 테이블 형식으로 저장
        - 각 테이블 마다 고유 식별자인 프라이머리 키를 할당.
            - 다른 테이블과 연결시켜주는 역할도 수행한다.
            - 연결된 두 테이블은 SQL 쿼리를 이용해 상호작용이 이루어진다.
    - 비관계형 데이터 베이스
        - 여러가지 형태로 저장이 될 수 있어서 다양한 데이터 모델을 사용한다.
        
    - 두 방식의 차이점
        - 데이터 저장 관리 방식
            - 관계형 데이터 베이스
                - 테이블 형식으로 저장되어서 데이터 변형 및 테이블 사이 엄격한 규칙을 따른다.
                - 데이터 무결성, 일관성을 유지하면서 정형화 된 데이터(테이블에 넣은 데이터)를 처리 할 수 있다.
                
            - 비관계형 데이터 베이스
                - 더 유연하며 변화가 많은 데이터에 보다 유용히 사용된다.
                - 이미지, 비디오 문서 등 비정형(정돈 되지 않은)데이터를 저장하는데 사용 될 수 있다.
                
- HTTP 메서드에서 멱등성이 중요한 이유
    - 멱등성이란
        - 동일한 연산을 여러 번 수행해도 결과가 달라지지 않는 성질을 말한다.
            
            → 동일한 요청을 한번 보내는 것과 여러번 보내는 것이 같은 효과를 가지고, 서버의 상태도 동일하게 남는 것을 뜻함
            
            → 어떠한 부수효과도 존재해서는 안되는 것을 뜻함(통계기록(어떠한 데이터들의 통계의 Count)를 제외함)
            
        - 이러한 성질은 데이터의 일관성, 안정성을 보장하는 데 핵심적인 역할을 한다.
    
    - 멱등한 요청인지 알 수 있는 방법
        - 멱등키를 API 요청에 포함시켜서 이전 요청과 멱등키를 비교합니다. (IETF에서는 요청 헤터에 포함시키는 것을 표준으로 삼는다)
            
            → 동일한 멱등키이면 요청을 처리하지 않고 이전 처리와 동일한 응답을 반환시킴
            
    
    - 멱등한 요청을 사용시 장점
        - 예측 가능성을 제공 : 여러번 멱등한 요청을 반복해도 같은 결과가 나오기 때문에 신뢰성을 높이고 예측 가능하게 된다.
        - 오류 처리의 단순화 : 오류가 발생하였을때 멱등한 성질을 이용하면 오류 처리가 간편해진다.
        - 캐싱, 로드 밸런싱에 도움 : 멱등 연산을 이용하면 로드 밸런싱을 쉽게 구현 가능하고, 멱등키를 이용하여 캐쉬된 응답을 내어줄수 있다.
            
            → 로드 밸런싱 : 모든 리소스 서버가 동일하게 사용 되도록하는 디바이스
            
        - 데이터의 일관성 유지 : 데이터의 무결성을 유지 할 수 있다.
        
    - 멱등키 관련 상태코드
        - 400 : 멱등키가 누락이 됐거나, 형식에 맞지 않은 키가 들어옴
        - 409 : 이미 이전 요청의 대한 처리가 진행중인데 같은 멱등키를 가진 요청이 들어옴
        - 422 :  요청한 내용이 다른데 이전 요청과 같은 멱등키를 사용한 경우
- SOP, CORS
    
    ### CORS(크로스 오리진 리소스 공유)
    
    → 추가 HTTP 헤더를 사용하여 한 출처에서 실행중인 웹 애플리케이션이 다른 출처의 자원에 접근 할 수 있는 권한을 부여해주는 브라우져 체제를 말할다.
    
    - 현재 브라우져의 URL(A) : 현재 오리진
    - 서드 파티 URL : 크로스 오리진
    
    ![Untitled](15%20%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2023de31da87ab4978b64bb0d7ba3d1466/Untitled%203.png)
    
    - 나오게 된 배경
        - 과거 CSRF 위조 문제 발생 : 피해자 브라우져에서 다른 애플리케이션으로 가짜 요청을 전송함
            
            → 이로 인해 오리진 정책을 실시하게 되었음(SOP)
            
        - 동일 오리진 정책은 안정성을 보장하지만 실제 사용에선 유연하지 않음
        - 서드 파티의 승인하에 리소스를 공유 할수 있는 CORS 가 나옴
    - CORS 과정
        
        ![Untitled](15%20%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2023de31da87ab4978b64bb0d7ba3d1466/Untitled%204.png)
        
        1. 브라우져는 현재 오리진의 프로토콜, 호스트, 포트에 대한 정보가 포함된 오리진 헤더를 요청에 추가시킴
        2. 서버는 오리진 헤더를 확인하고 요청된 리소스와 Access-Control-Allow-Origin 헤더로 응답
        3. 브라우저는 Access-Control-Allow-Origin 헤더를 확인후 반환된 데이터를 클라이언트 애플리케이션과 공유