# 14주차 과제 정리

## 1.Node.js

**→V8 Java Script 엔진으로 빌드 된 Java Script 런타임**

- 웹 브라우져 밖에서도 자바스크립트를 사용하게 할 수 있게 해준다.(서버, GUI프로그램)
    
    → 자바스크립트를 서버로 부터 독립시켜 서버 구현을 가능케 함
    
- 6개월 동안 Current 버전으로 출시 → LTS 버전
- LTS 버전 Long Term Support 장기간 지원 받을 수 있는 버전
    
    → 안정성 보장
    

### Node.js 는 프레임 워크일까 ?

→ 프레임워크가 **아니고,** 단순 **자바스크립트 언어의 실행 환경**

### REPL 모드

→ 짧은 코드를 간단하게 실험하고 싶을 때 사용

- Read : 사용자가 입력한 내용을 읽고
- Eval : 그결과값을 구해서
- Print : 결과값을 출력한 다음
- Loop : 이런 일련의 과정을 반복하는 것을 의미

### 모듈 이란 ?

→ 전체를 이루는 부품 하나하나 (자바스크립트에선 파일 하나를 뜻함)

### Node.js 강점

- 비동기 이벤트 기반 환경(Non-Blocking)
    
    → 입출력 작업을 기다리는 동안 다른 작업을 수행 할 수 있게 해줌(CPU를 효율적으로 사용 가능)
    
- 요청이 많을때 멈추거나 요청 대기 시간이 발생하지 않습니다.(비동기)
- 코드가 매우 짧고 쉬워서 빠른 개발이 가능하다.
    
    → 개수는 많지만 크기가 작은 데이터를 실시간으로 주고 받기에 적합
    
- 단일 언어 사용 → 자바스크립트
    - 개발자들의 생산성을 향상시켜줌
- 확장성이 좋음
    
    → 새로운 모듈을 추가하거나 업데이트 하는 과정이 무척 간단함 Node.js 단점
    
- 스레드 하나에서 처리 되기 때문에 코드가 CPU 연산을 많이 요구하면 스레드 하나에 감당하기 어려움
    
    → 비디오, 이미지, 대규모 데이터 처리는 권장하지 않는다.
    

### Express 란?

- Node.js 런타임 환경에서 구동되는 유명한 프레임워크
    - 프레임워크란 ?
        
        → 일정한 틀을 갖고 있어서, 개발자가 특정 부분만 원하는 모습대로 채워 넣으면, 프로그램을 완성할 수 있게 해주는 준비된 코드 체계
        
        - 재사용 가능한 코드와 패턴을 제공하여 → 개발 시간 단축, 효율성을 증가시킴
        - 필요한 기본 구조와 함께 개발자가 사용할 수 있는 여러 기능과 도구들을 포함
        
- middleware
    - 일반적으로 next 라는 변수로 쓰인다
    - request object , the response object, 다음 미들웨어 함수에 접근 가능
    - 역할
        - 코드를 실행합니다.
        - 요청 및 응답 객체를 변경합니다.
        - 요청, 응답 사이클을 종료시킨다.
        - 스택에서 다음 미들웨어 함수를 호출 합니다.
- Error Handling
    
    → 발생할 수 있는 오류를 캡쳐하고 처리하는 과정을 말함
    
    - 동기적 오류 와 비동기적 오류로 나눌수 있음
        - 동기적오류 : 코드에서 발생하는 오류
        - 비동기적오류 : 네트워크 시간초과, 외부 API오류
    - 필요한 이유
        - 오류가 발생하면 애플리케이션이 올바르게 작동하지 않기 때문
        - 사용자가 알 수 없는 오류메세지가 나타날 수 있음
        - 안정적이고 일관적인 사용자 경험을 제공하는 것이 중요

### 서버측 웹 사이트 프로그래밍

→ 클라이언트의 요청(검색, 삭제, 등등)(HTTP request)을 기다리고 요청이 도착하면 작업을 진행하여 웹 브라우져에 HTTP 응답 메세지(HTTP resource)를 보내준다.

- HTTP request 요청에는 URL, URL매개변수 (query 문자열에 필드 key-value 쌍), POST 데이터, 원하는 작업 메서드, associated cookies를 이용한 인코딩된 추가 정보
    - 인코딩이란?
        
        인코딩은 정보를 컴퓨터가 이해할 수 있는 형태로 변환하는 과정
        
- 응답 메세지 : 성공 → 요청 리소스를 포함, 실패 → 실패 관련 에러 메세지(403,404 ..등등)

### 정적 웹사이트

→ 특별한 리소스 요청이 들어올 때 서버에서 하드 코딩된 동일한 콘텐츠를 반환 (블로그, 정보관련 문서)

- 주로 HTML, CSS, javaScript 같은 정적파일로 구성

![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled.png)

### 동적 웹사이트

→ 사용자또는 저장된 환경을 기반으로 URL에 대해 다른 데이터를 반환 할 수 있으며, 응답을 반환하는 과정에서 다른 작업을 수행 할 수 있습니다.(쇼핑 웹사이트, 온라인 은행, 소셜 네트워크)

- 동적 웹사이트를 지원하는 코드는 서버에서 실행 되어야 하고 이러한 코드를 : **server-side programming 라고 부른다(back-end scripting)**

![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%201.png)

- 방식 : HTML 템플릿에 있는 자리 표시자에 데이터베이스에서 가져온 데이터를 넣어 생성 됩니다 —> 조사 필요
- 구현 : 서버 측 프로그래밍 언어(PHP, Python 등)나 프레임워크(ASP.NET, Ruby on Rails 등)를 사용하여 구현

### 서버측 프로그래밍 vs 클라이언트측 프로그래밍

- 클라이언트측 프로그래밍 (**client-side code)**
    - HTML, CSS, javaScript 로 작성 됨
    - 주 관심사 : 렌더링된 웹페이지의 모양과 행동을 개선
    - 단점 : 브라우저 지원의 차이를 정상적으로 처리 하는 것
- 서버측 프로그래밍(**server-side code**)
    - 개별 사용자에 맞게 정보를 효율적으로 전달
        - 일반적이거나 유저 특화된 알람을 보내 줄 수 있음
    - 효율적인 저장소와 정보 전달
        - 정보를 데이터베이스에 저장하고 동적으로 HTML, 기타 유형 파일을 동적으로 생성 및 반환
        - 간단한 데이터(JSON, XML)도 반환가능
    - 컨텐츠에 대한 접근 제한
        - 특정 사용자에 대해 접근하거나 제한을 걸어줄 수 있다.
    - 사용자의 대한 많은 정보를 수집할 수 있다.
        - 데이터 분석으로 응답을 구체화 할 수 있다.
    - 다양한 언어로 작성 될 수 있음(PHP, Python, Ruby 그리고 C#)
    - 주 관심사 : 대부분 브라우저의 요청에 대한 응답처리
        - 제출 된 데이터 및 요청의 유효성 검사
        - 데이터 저장 및 검색을위한 데이터베이스 사용
        - 필요에 따라 올바른 데이터 전송

## 상태코드

### → 상태코드란 : 클라이언트 측의 HTTP 요청에 대한 서버의 응답을 숫자로 표현해서 나타낸것을 의미한다.(W3C에서 설정한 3자리 숫자를 의미한다)

### 상태코드의 중요성 및 의의

→ 웹 서버와 클라이언트 간 통신에서 발생할 수 있는 다양한 상황을 표현하고 전달하는 데 중요한 역할을 해준다.

1. 통신 신뢰성을 확보
    - 클라이언트에게 서버 요청의 대한 결과를 신속하고 명확하게 전달해서 이를 통해 클라이언트는 빠른 대처를 할 수 있고 시스템이 예상대로 동작한는지 확인하는데 중요한 역할을 해줍니다.
2. 오류처리와 디버깅
    - 이 역시 클라이언트 측에서 상태코드를 바탕으로 오류를 구별하고 이를 통해 적절한 조치를 빠르게 취할 수 있게 해준다.
3. 네트워크 성능 최적화
    - 클라이언트와 서버 간의 통신을 최적화 시켜주고, 효율적으로 네트워크를 관리하게 도와준다.
4. 사용자 경험 개선
    - 사용자가 요청의 대한 원하는 응답을 받지 못했을경우 불편함을 최소화하고 대안을 찾을 수 있게 도와줌
5. SEO 검색 엔진 최적화
    - 검색 엔진은 웹 페이지의 상태코드를 분석하여 페이지 상태를 이해하고 인덱싱하므로 올바른 상태 코드를 사용하면 검색 엔진에서 웹사이트를 올바르게 평가하고 검색결과를 정확도 또한 향상 시킬수 있다.
6. 표준화와 호환성
    - HTTP 상태 코드는 RFC(Request for Comments) 문서에 저장 돼서 모든 웹 서버와 클라이언트가 일관된 방식으로 상태를 처리할 수 있게 해주고, 이는 다양한 플랫폼 간의 상호 호완성을 보장시켜주고, 표준화 시켜줍니다.

### 상태코드 정리

### 정보 응답

 → 임시 응답으로 최종 응답 전에 요청의 상태나 요청 진행 상황을 알리기 위한 중간 응답을 나타낸다. 

- HTTP/1.0 1xx 상태 코드 정의하지 않음 → HTTP/1.0 클라이언트에겐 보내면 안됨
- 프록시는 1xx 응답을 반드시 전달해야 한다. (자체적으로 서버에 생성을 요청한 경우는 제외)
- 100 : Continue
    
    → **서버로 보낸 요청에 문제가 없어서 다음 요청을 계속 보내도 된다는 것을 의미**
    

- 101 : Switching Protocols
    
    → **클라이언트가 보냈던 프로토콜 Upgrade 요청의 대한 헤더에 응답을 말하며, 서버에서 이제 프로토콜을 변경할 것을 클라이언트에게 알려주는 역할을 한다.**
    
    - 웹소켓 (websocket) 프로토콜로 전환할 때나 이전 HTTP 버전을 새로운 HTTP 버전으로 바꿀때 사용
    - 웹소켓이란?(websocket)
        
        서버와 브라우저 간 연결을 유지한 채로 데이터 교환할 수 있게 해주는 역할
        
        - 데이터는 패킷 형태로 전달 되며 전송은 커넥션 중단과 추가 HTTP 요청 없이 **양방향으로 이루어진다**
        - 종료시점은 서버나 클라이언트 중 하나에 의해 종료되거나, 시간 초과에 의해 닫힐 때까지는 열린 상태를 유지합니다.
        - HTTP 는 초기 핸드셰이크에 사용되며(101 상태코드를 사용하기 위해) 핸드셰이크가 성공하면 TCP 소켓이 항상 열려있어서 이를 사용해 양방향 소통이 이루어진다
        - 핸드셰이크란 ?
            
            통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 서로 인지 확인하는 과정이 악수와 비슷하여 붙여진 이름
            
            - 여러가지 방식이 존재한다. **TCP 3-Way Handshake**, UDP Handshake, TLS Handshake 등등…
            - websocket 에서는 자체적인 핸드셰이크 방식 사용
                1. 클라이언트가 서버로 HTTP 요청을 보낸다. (다음과 같은 요청)
                    
                    ```jsx
                    GET /chat HTTP/1.1
                    Host: exampl
                    Upgrade: websocket                   // 연결을 websocket으로 하고 싶음을 나타냄
                    Connection: Upgrade                  // 업그레이드 요청
                    Sec-WebSocket-Key: ~~~~~~~~~~~~~~    // 고유의 키값으로 이를 서버에서 받아서 응답키를 생성
                    Sec-WebSocket-Version: 13             // websocket 버전 지정
                    ```
                    
                2. 서버가 클라이언트 요청을 확인후 응답을 보낸다.
                    
                    ```jsx
                    HTTP/1.1 101 Switching Protocols       // 성공적으로 요청을 받고 업그레이드 했음을 표시
                    Upgrade: websocket                    //  websocket 프로토콜로 업그레이드 됐음을 나타냄
                    Connection: Upgrade                   // 연결 업그레이드가 완료됨
                    Sec-WebSocket-Accept: **************  // 요청에 Sec-WebSocket-Key를 기반으로 만든 키
                    ```
                    
                3.  클라이언트 측에서 받은 **Sec-WebSocket-Accep**t 와 **Sec-WebSocket-Key** 를 검증해서 일치하면 양방향 통신 시작~!
- 102 : Processing
    
    → **이 코드는 서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로 된 응답을 알려줄 수 없는것을 알려준다. (요청을 처리하는데 오래걸리경우 사용)**
    
    - **사용이 중지되어서 더이상은 사용하지 않고 권장 되지 않는다**고 한다.(웹 표준에서도 삭제)

- 103 : Early Hints
    - **서버가 응답을 준비하는 동안 Link 헤더를 사용하여 사용자가 사전로딩을 할 수 있게 해주는 응답코드**
    - Link Header
        
        → 링크를 직렬화하기 위한 수단을 브라우저(사용자, 클라이언트)에게 제공하는 헤더를 나타낸다.
        
        - 브라우저에 특정 URI 참조를 처리하는 방법을 알려주는 역할을 한다.
        - 페이지 개선을 위해 사용 된다.
        - 웹 페이지를 더 빠르게 로드하기 위해 무엇을 해야하는지 파악 할 수 있다.
    - 직렬화
        
        → 직렬화 또는 시리얼라이제이션은  객체나 데이터 구조를 네트워크나 저장소(배열 버퍼 또는 파일 형식)를 통한 전송에 적합한 형식으로 변환하는 프로세스입니다. (JSON.stringify)
        
    

### 성공 응답 (200~206)

→ **클라이언트의 요청이 서버에서 성공적으로 처리 된것을 의미한다.**

- **200 OK**
    
    → **요청이 성공적으로 된 것을 의미한다.**
    
    - HTTP 요청 메서드에 따라 나뉘기 때문에
        - GET: 리소스를 잘 가져와서 응답으로 보내줌
        - HEAD: 메세지 바디 없이 표현 헤더에 응답이 포함되어 있다는 것을 의미
        - POST: 리소스가 명시하는 행동의 결과가 메세지 본문에 전송되었다는 것을 의미한다.
        - TRACE: 서버가 요청받은 메세지가 메세지 본문에 잘 포함되어 있다는 것을 의미한다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%202.png)
        
- **201 Created**
    
    **→ 요청이 성공적으로 처리 되었으며 resource 가 성공적으로 생성된 것을 나타내는 응답코드(일반적으로 POST 요청 결과)**
    
    - 응답 메세지 본문에 새로 만들어진 resource 설명과 링크(요청 URL, Location 헤더 값의 URL)를 본문에 넣어서 반환해줍니다.
        - Location 응답 헤더
            
            리다이렉트 할 페이지의 URL이나 새로 만들어진 리소스의 URL 을 나타냄 
            
        - 요청 URL
            
            리소스 위치를 지정하는 URL을 의미한다.(특정 웹페이지나 리소스에 접근하기 위해 브라우저에 입력하는 웹 주소)
            
        
- **202 Accepted**
    
    **→ 클라이언트(사용자)로 부터 받은 요청이 아직 처리중이거나 시작되지 않은 것을 의미한다.** 
    
    - 이 상태코드는 모호한 것을 의미 → HTTP가 나중에 요청 처리 결과를 나타내는 비동기 응답을  보낼 방법이 없는 것을 의미
    - 목적 : 프로세스가 완료 될때까지 사용자 에이전트의 서버 연결 유지 필요없이 다른 프로세스에 대한 요청을 수락할 수 있도록 하기 위한 목적
    - 요청의 현재 상태를 설명해야 하고 사용자에게 요청이 언제 완료 될지 예상할 수 있는 상태모니터를 포함시켜야 합니다.
- **203 Non-Authoritative Information**
    
    → **요청이 성공적으로 처리 되었지만 내용이 변형 프록시에 의해 원 서버의 응답 200(OK) 응답과 달라진 것을 나타낸다.**
    
    - 프록시
        
        → 클라이언트 와 서버 사이에 존재하며 중계기로써 대리로 통신을 수행하는 것을 의미한다.(중계 기능 주체를 proxy Server 라고 한다)
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%203.png)
        
    - 변형 프록시
        
        → 일부 프록시에는 메세지와 그 내용을 변환하는 기능이 포함되어 있어서 내용을 변형시킬 수 있는데 이때 의미 있는 방식으로 수정하도록 설계 또는 구성 되어 있는 것을 말한다
        
        - 의미 있는 방식이 아닌경우(의도치 않은 변형)
            - 무결성 검사나 디지털 서명을 사용하여 수신된 콘텐츠가 원본과 동일한지 확인하는 경우 운영상의 문제가 발생할 수 있습니다
        - 의미 있는 방식인 경우(의도해서 변형)
            - 공유 주석 서버 역할(응답을 수정해서 주석 데이터베이스에 대한 참조를 포함시킴)
                - 악성 코드 필터, 포맷 변환기, 개인 정보 필터 역할로 작동 할 수 있다.
    
- 204 No Content
    
    **→ 성공 상태 응답 코드는 요청이 성공했으며 응답 콘텐츠로 전송할 추가 콘텐츠가 없음을 나타냅니다**
    
    - HTTP Response body 가 아예존재 하지 않는것을 의미합니다.
    - 추가로 클라이언트가 현재 페이지에서 벗어나지 않아도 되는 것을 나타낸다.
    - 204 응답은 기본적으로 캐시가 가능하며 캐시에서 가져온 응답의 경우 ETag 헤더를 포함한다.
        - ETag
            
            → 특정버전의 리소스를 식별하는 식별자를 말한다. 
            
            - 지문과 같은 역할로 다른 서버들을 추적하는 용도로 사용되기도 한다.
            - 웹 서버 내용을 확인해서 내용이 변하지 않았으면 full request 요청을 보내지 않아도 돼서 캐시가 효율적이고 대역폭도 아낄 수 있다.
            - 웹 서버 내용이 변경되었으면 mid-air collisions 라는 리소스간의 동시 다발적 수정 및 덮어쓰기 현상을 막는데 유용하게 사용된다.
            
            ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%204.png)
            
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/f5ddf1d7-faf7-4c22-b855-a228fb755d5c.png)
        
- 205 : Reset Content
    
    → **사용자 또는 클라이언트가 요청을 전송한 document view 를 원본서버의 원래 상태로 재설정하기를 원하는 것을 나타낸다.**
    
    - 다음 입력 작업을 쉽게 시작할 수 있도록 입력 메커니즘을 초기화해야 할 때 사용
        - document view
            
            → 프로필에서 문서 속성, 문서 작업 및 프로세스 작업이 활성화되는 권한을 설정하는 것을 말함
            
            - 문서 속성을 읽기 - 쓰기, 읽기 전용, 숨김 등으로 설정할지의 대한 여부와 문서 작업의 활성 또는 비활성 여부도 제어 할 수 있다.
        
- 206 : **Partial Content**
    
    →  **Range 헤더에 쓰여진 데이터 범위에 대한 요청이 성공적으로 응답되어 본문에 해당되는 데이터를 담고 있다는 것을 알려준다**
    
    - Range HTTP 요청 헤더
        
        → 서버에게 문서 일부분만 보내주기를 요청한다. 
        
        - 서버에서 성공적으로 보내주면 206 상태코드를 보내주고
        - 범위가 유효하지 않으면 416
        - 범위를 무시하고 문서 전체를 보내줄경우 200을 내보내준다.
        
    - 해당 범위가 단일 범위 일때 : Content-type은 document로 설정되고 Content-Range가 제공됨
    - 해당 범위가 여러 범위 일때 : Content-type 은 multipart/byteranges 로 설정되고 데이터 응답은 Content-Range, Content-Type 로 각각의 범위를 설명해줍니다.
        - Content-Range, Content-Type
            - Content-Range HTTP 응답 헤더 : 전체 메세지에서 부분 메세지가 속한 위치를 알려주는 역할
            - Content-type 헤더는 : 리소스의 미디어 타입을 나타내기 위해서 사용된다.
                
                
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%205.png)
        

### 리다이렉션 메세지 (300 ~ 308)

→ **완전한 처리를 위해 추가 동작이 필요한 것을 의미한다.**

- 300 **Multiple Choices**
    - **요청에 대한 가능한 응답이 두개 이상이 있을때 보내주는 코드**
        - 사용자는 두개 이상중 하나를 선택해야하는데 선택하는 표준화된 방법이 없기 때문 잘 사용되지 않는다.
        - 서버측에서 원하는 항목이 있을경우 Location 을 생성한다.
            - Location 응답 헤더 : 리다이렉트할 페이지의 URL을 나타낸다.
            
- 301 **Moved Permanently**
    
    **→ 대상 리소스에 새 영구 URL이 할당 되어서 추후 이 리소스의 대한 참조는 보내준 URL중 하나를 사용해야 하는 것을 나타낸다.**
    
    - 링크 편집 기능이 있는 사용자(클라이언트)에게 URI의 대한 참조를 서버가 보내준 새 참조중 하나로 영구적으로 대체할 것을 제한하는것을 의미
    - 단순 제안이여서 사용자(클라이언트)가 참조의 대해 적극 편집과 연결이 안전하고 신뢰할 수 있는 기관인 경우 이 상태코드는 일반적으로 무시될수 있다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%206.png)
        
    
- 302 Found
    
    **→ 요청한 리소스가 일시적으로 다른 URI 에 있음을 나타낸다**
    
    - 서버는 응답에 다른 URI 에 대한 참조가 포한된 Location 필드를 생성해야한다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%207.png)
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%208.png)
        
- 303 See Other
    
    **→ 서버가 사용자(클라이언트)를 다른 리소스로 리디렉션하고 있음을 알려주어서 요청의 대한 간접적인 응답을 제공한다.**
    
    - Location 필드에 역시 URI를 표시해야한다. (이때 URI는 원래(기존) URI와 동일하지 않는다)
    - 이 상태코드는 모든 HTTP 메서드의 대해서 사용가능하다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%209.png)
        
    
- 304 Not Modified
    
    **→ 조건부 GET 또는 HEAD 요청의 대한 응답으로 요청의 조건이 false 가 아니였으면 200을 응답 받았을 것을 나타낸다.( If-None-Match 또는 If-Modified-Since 헤더를 사용할 때 사용되는 코드)**
    
    - If-None-Match, If-Modified-Since 헤더
        
        추후 보완
        
    - 조건이 false 로 평가되어서 서버는 대상 리소스의 표현(representation)을 전송할 필요가 없음을 의미한다.
        - representation
            
            어떤 리소스의 특정 시점의 상태를 반영하고 있는 정보를 말한다.
            
    - 즉 : 클라이언트 측에서 이미 유효한 표현을 가지고 있어서 클라이언트에게 저장된 그 표현을 200(OK) 응답의 내용처럼 사용하도록 지시하는 것을 의미한다. (클라이언트는 이미 가지고 있는 데이터를 계속 사용할 수 있음을 나타냄)
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%2010.png)
        
- 307 Temporary Redirect
    
    **→ 대상 리소스가 다른 URI 에 임시로 존재하며 사용자(클라이언트)가 해당 URI 로 자동 리다이렉션을 수행하는 경우 요청 방법을 변경하지 않아야 하는것을 나타낸다.**
    
    - 리디렉션은 시간이 지남에 따라 변경될 수 있으므로 클라이언트는 향후 요청에 대해 원래 원본 URI 를 계속 사용해야 한다.
    - 서버는 다른 URI 의 대한 참조를 포함하는 Location 헤더 필드를 생성해야 한다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%2011.png)
        
    
- 308 Permanent Redirect
    
    **→ 대상 리소스의 새 영구 URI가 할당되었으며 향후 이 리소스의 대한 모든 참조는 보내준 URI중 하나를 사용해야 하는것을 나타낸다** 
    
    - 링크 편집 기능이 있는 사용자(클라이언트)에게 URI의 대한 참조를 서버가 보내준 새 참조중 하나로 영구적으로 대체할 것을 제한하는것을 의미
    - 단순 제안이여서 사용자(클라이언트)가 참조의 대해 적극 편집과 연결이 안전하고 신뢰할 수 있는 기관인 경우 이 상태코드는 일반적으로 무시될수 있다.
    - 서버는 새 URI 가 포함된 Location 헤더 필드를 응답으로 보내주어야한다.
    

### 클라이언트 에러 응답 (400 ~ 426)

→ 없는 페이지 요청하는 등 클라이언트의 요청 메세지 내용이 잘못된 것을 의미한다.

- 400 Bad Request
    
    → **클라이언트 측 오류로 인식되는 문제 (잘못된 요청 구문, 잘못된 요청 메세지 프레이밍, 잘못된 요청 라우팅) 으로 서버가 요청을 처리할 수 없거나 처리하지 않았을때 보여주는 상태코드**
    

- 401 Unauthorized
    
    **→ 대상 리소스에 대한 유효한 인증 자격 증명이 없기 때문에 요청이 적용되지 않은것을 나타낸다.**
    
    - 서버에서는 응답으로 대상 리소스에 적용 가능한 챌린지 하나 이상을 포함하는 WWW-Authenticate 헤더 필드를 반드시 보내야한다
        - WWW-Authenticate 헤더 필드
            
            대상 리소스에 적용되는 인증 체계 및 매개 변수를 나타내서 챌린지 하나 이상을 포함해야 한다.
            
            - 중계 프록시가 있는경우 해당 필드를 수정해선 안된다.
            - 둘이상의 챌린지가 포함될 수 있다.(” , ” 로 구분)
        - Challenge & Response
            1. 인증에서 사용되는 난수값으로 서버측에서 클라이언트측으로 보내주면 
            2. 클라이언트 측에서 해당 값을 private key로 sign하고 다시 되돌려 주는데 
            3. 이때 받은 sing값을 서버는 Public Key로 verify하고 처음 보낸 challenge값이 맞는지 비교해서
            4. 검증을 진행하는 방식을 말한다.
    - 요청 인증 자격이 포함된 경우에서 401 응답은 해당 자격 증명에 대한 권한이 거부 됐음을 의미한다.
    - 사용자(클라이언트)측에선 새로운 Authorization 헤더 필드를 추가하거나 기존의 자격 증명을 교체하여 요청을 반복할 수 있다.
    - 만약 401 응답이 이전 응답과 동일한 도전을 포함하고 있고, 클라이언트가 이미 최소한 한 번 인증을 시도했다면, 일반적으로 클라이언트는 사용자에게 관련 진단 정보가 포함된 표현을 표시해야 합니다.
        - user agent
            
            사용자 대신 일을 수행하는 소프트웨어를 지칭한다.
            
        
- 402 Payment Required
    - 향후 사용을 위해 예약되어 있는코드
    
- 403 Forbidden
    
    **→ 서버가 요청을 이해했지만 요청을 처리하지 않았음을 나타내는 코드이다.**
    
    - 요청이 금지된 이유를 공개하고자 하는 서버는 응답 내용에 해당 이유를 설명할 수 있습니다.
    - 요청에 인증 자격 증명이 제공된 경우 서버는 해당 자격 증명이 액세스를 허용하기에 충분하지 않은 것으로 간주한다.
    - 클라이언트는 동일한 자격 증명으로 요청을 자동으로 반복해서는 안 되지만 새 자격 증명 또는 다른 자격 증명을 사용하여 요청을 반복할 수는 있다.
    - 금지된 대상 리소스의 대해 존재를 숨기기위해 404 코드로 응답할 수 도 있다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%2012.png)
        
    
- 404 Not Found 
**→ 원본 서버가 대상 리스스에 대한  current representation 을 찾지 못했거나 공개하고 싶지 않을때 나타내는 코드입니다.**
    - 이 상태 코드에서 일시적인지 영구적인지를 나타내지 않고 서버측에서 영구적일 가능성이 있다고 판단될 경우 410 코드를 더 선호한다.
    - 휴리스틱 방식으로 캐시할 수 있다.
        - 휴리스틱 방식으로 캐시
            
            합리적인 판단을 할 수 있는 시간이나 정보등이 불충분하거나 합리적인 판단이 필요없는 경우 신속하게 처리하는 방식
            
            - 서버가 항상 명시적인 만료 시간을 제공하지 않아서 그럴듯한 만료 시간을 추정하는 알고리즘을 사용하여 만료 시간을 할당할 수 있다.
        
        ![Untitled](14%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20d3950f9caaed41cbbf2cb6230acf89f1/Untitled%2013.png)
        
- 405 Method Not Allowed
    
    **→ 해당 메서드를 서버에서 인지는 하고 있지만 대상 리소스에서는 지원되지 않는것을 나타낸다**.
    
    - 서버측에서는 해당 리소스에 지원 메서드 목록이 포함된 Allow header 필드를 생성할 수 있다.
        - Allow header 필드
            
            해당 리소스의 대한 사용가능한 메소드 집합이 나열된 필드입니다.
            
    - 이 상태코드 역시 휴리스틱 방식으로 캐시할 수 있다.

- 406 Not Acceptable
    
    **→ 클라이언트가  proactive negotiation header fields로 요청한 리소스가 서버에서 제공할 수 있는 representation가 없거나 해당 representation 이 클라이언트가 원하는 형식에 적합하지 않을때 발생하는 코드**
    
    - 서버는 이 코드와 함께 함께 클라이언트가 선택할 수 있는 다양한 representation 과 리소스 식별자를 포함한 컨텐츠를 생성해야 합니다.
        
        → 이를 통해 클라이언트나 사용자가 가장 적합한 선택지를 자동으로 선택할 수 있다. 
        
        - proactive negotiation header fields
            
            요청시 Accept, Accept-Language, Accept-Encoding 등 헤더 필드들로 클라이언트가 요청을 보낼 때 서버에게 선호하는 데이터 표현을 선택하도록 유도하는 메커니즘을 일컫는다.
            
- 407 Proxy Authentication Required
    
    **→ 클라이언트가 요청을 보낼때 프록시를 사용할때 해당 프록시에 대한 인증이 필요할때 보내주는 상태코드이다.**
    
    - 클라이언트는 요청을 보내기 전에 해당 프록시 서버에 대해 인증을 해야 한다.
    - 상태코드를 보낼때 반드시 Proxy-Authenticate 헤더 필드를 포함해서 보내야한다.
        - Proxy-Authenticate 헤더 필드
            
            클라이언트가 인증이 필요한 프록시에 자신을 식별할 수 있게 해준다. 
            
            - 리소스의 프록시 및/또는 영역에 대한 클라이언트의 인증 정보가 포함된 자격 증명으로 구성된다.
        
- 408 Request Timeout
    
    **→  서버가 요청을 받기 위해 준비한 시간 내에 완전한 요청 메시지를 받지 못했음을 나타낸다.**
    
    - 주로 네트워크 연결이 불안정하거나 요청을 처리하는데 너무 오랜 시간이 걸리는 경우 발생할 수 있다.
    - 클라이언트가 아직 처리 중인 요청이 있다면, 해당 요청을 반복할 수 있다.
    - HTTP/1.1에서 요청의 경계(delimitation)가 분실된 상태에서 현재 연결을 계속 사용할 수 없는 경우
        - 요청의 경계(delimitation) 분실
            
            HTTP/1.1 프로토콜에서 발행할 수 있는 상황으로 연결 기반 프로토콜에서 클라이언트 요청이 끝나는 시점을 명확하게 인식하지 못하여 발생하는 문제를 의미한다. 
            
            - 명시적인 구분자를 정의하지 않아서 발생할하거나 요청이 지연되거나, 네트워크 연결이 불안정할 때 발생할 수 있다
            - HTTP/2와 같은 후속 버전에서는 이러한 문제를 개선하기 위한 다양한 메커니즘이 추가되었다.
                - Binary Framing Layer : 이진 프레임(기본 I-프레임(키 프레임)과 비교하여 변화된 부분만을 저장하는 프레임)을 사용하여 데이터를 전송한다.
                - Multiplexing :  단일 TCP 연결을 통해 동시에 여러 요청과 응답을 처리.
                - Header Compression : 헤더 필드들을 압축하여 전송한다. —> 네트워크 대역폭을 절약하는 데 도움을 준다.
        
- 409 Conflict
    
    → **대상 리소스의 현재 상태와 충돌로 인해 요청을 완료할 수 없는 것을 나타낸다.**
    
    - 사용자(클라이언트)가 충돌을 해결하고 재요청이 가능한 상황의 대해서 사용된다.
    - 충돌의 원인을 인식할 수 있는 충분한 정보를 포함하는 콘텐츠를 생성해야 한다. (보통 PUT 요청)
    
- 410 Gone
    
    **→ 해당 리소스가 원본 서버에서 더 이상 이용할 수 없으며 이 상태가 영구적으로 지속될 것으로 예상될 때 보여주는 코드(영구적으로 삭제 됐거나, 이용할 수 없을때)**
    
    - 영구적인지 불확실한 경우엔 404 코드를 보내주어야 한다.
    - 410 응답을 웹 유지 보수에 사용 되는데 제한된 기간 동안 프로모션 서비스나 원본 서버와 관련이 없어진 개인 리소스와 같은 경우 서버가 의도적으로 리소스를 사용할 수 없게 만들었음을 수신자에게 알려주고 원격 링크가 제거 되기를 원할때 사용된다.
    - 휴리스틱하게 캐시될 수 있다.
    
- 411 Length Required
    
    **→ 서버에서 클라이언트 측 요청을 받아들이기 위해서는 요청의 본문의 길이를 명확히 알 필요가 있어서 발생시키는 오류로 요청에 Content-Length 헤더 필드가 포함되어 있어야한다.**
    
    - Content-Length 헤더 필드란?
        
        연결된 representation 의 데이터 길이를 10진수가 아닌 옥텟 진수로 나타낸 필드를 말한다.
        
    
- 412 Precondition Failed
    
    → **클라이언트가 요청한 자원의 상태가 서버에서 기대하는 조건과 일치하지 않아서 요청을 처리할 수 없음을 나타낸다.**
    
    - 요청 헤더 필드에 설정한 하나 이상의 조건이 서버에서 다시 평가 되었는데 false로 나온 경우를 말한다.
    - 클라이언트는 적절한 조치를 취하거나 요청을 수정하여 다시 시도 할 수 있다.
    
- 413 Content Too Large
    - **요청 콘텐츠가 서버가 처리할 수 있거나 처리할 수 있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있음을 나타내는 것을 뜻한다.**
    - 프로토콜 버전이 허용하는 경우 요청을 강제 종료 시킬수 있다.
    - Retry-After 헤더 필드에 언제 다시 시도할 수 있는지 명시해서 클라이언트 측에서 다시 시도할 수 있도록 해줍니다.
    
- 414 URI Too Long
    
    → **대상 URI가 서버가 해석할 수 있는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있음을 나타낸다.**
    
    - 클라이언트가 무한 리디렉션 루프에 빠진 경우도 포함이다.
        - 자기 자신의 접미사가 리디렉션으로 자기 URI 접두사를 가리키고 있는경우
    - 클라이언트가 서버의 잠재적 보안 취약점을 이용하여 서버를 공격을 하고 있는 경우
    - 이 상태코드 또한 휴리스틱하게 캐시 가능하다.
    
- 415 Unsupported Media Type
    
    **→  콘텐츠가 대상 리소스에서 이 방법을 지원하지 않는 형식(format)이기 때문에 원본 서버에서 요청을 거부할때 보여주는 상태코드입니다.**
    
    - 이때 형태 정보는 요청에 표시된 Content-Type 또는 Content-Encoding 또는 직접 데이터를 검사해서 알 수 있다.
    - Accept 응답 헤더 필드를 사용하여 요청에 허용되었을 미디어 유형을 표시해야 합니다.
        - Accept 응답 헤더 필드
            
            동일한 리소스에 대한 후속 요청 콘텐츠에서 선호 되는 컨텐츠 유형 정보를 담는 필드이다.
            
    - Accept-Encoding 헤더 필드 사용하여 요청에서 허용 할 수 있는 컨텐츠 인코딩을 나타내야 합니다.
        - Accept-Encoding 헤더 필드
            
            콘텐츠 인코딩 사용에 관한 기본 설정을 나타내는 데 사용할 수 있습니다
            
            - 서버가 응답에서 보내는 경우 동일한 리소스에 대해 어떤 콘텐츠 인코딩이 선호되는지 정보를 제공해준다.
        
- 416 Range Not Satisfiable
    
    **→ 요청의 Range 헤더 필드에 있는 범위 집합이 만족할 만한 범위가 없거나 클라이언트가 지나치게 작거나 겹치는 범위를 요청했기 때문에 거부 되었음을 나타내는 상태코드**
    
    - Content-Range 헤더 필드를 포함하여
        - Content-Range 헤더 필드
            
            일반적으로 선택된(파일)의 표현의 범위를 나타내는 필드로 메세지 내용으로 여러가지가 올 수 있는데
            
            - 206 일때 → 선택된 표현의 부분 범위를 나타낼때 사용 된다.
            - 416 일때 → 선택된 표현의 길이를 나타내어 왜 만족할 수 없는지에 대한 설명도 같이 넣어준다.
        
- 417 Expectation Failed
    
    → **클라이언트가 요청한 Expect 헤더 필드의 Expection을 서버가 충족시키지 못했을때 보여주는 코드**
    
    - Expect 헤더 필드
        
        클라이언트 측에서 Expect 헤더 필드를 사용하여 서버에게 특정 조건을 만족시키거나, 기대하는 응답코드 같은 것을 명시할때 사용된다.
        
    
- 418  I'm a teapot
**→ 1998년 4월 1일에 April Fools' Day를 기념하기 위해 장난으로 등록된 상태코드**
    - 비록 장난으로 등록되었지만 개발자들 사이에서 많은 인기를 얻기도 했고, 때때로 웹 서버나 애플리케이션에서 이 코드를 이스터 에그 혹은 장난삼아 사용하기도 했습니다
    - 너무 많이 남용되어서 현재는 사용되지 않는다.
    
- 421 Misdirected Request
**→ 클라이언트가 요청한 리소스에 대해 적절한 응답을 생성할 수 없는 서버요청이 전송되었을 경우 나타내는 코드**
    - 요청된 URI가 서버에 설정된 origin 중 어느 것과도 일치하지 않을때 발생할 수 있다.
    - 요청이 도착한 연결이 서버가 기대하는 연결 컨텍스트와 일치하지 않을 때도 발생할 수 있습니다
    - 프록시는 이 상태코드를 생성해서는 안되고 오리진 서버나 게이트 웨이서만 사용되어야 한다.
    
- 422 Unprocessable Content
    
    **→ 데이터는 형식적으로 올바르지만 서버가 포함된 지시 사항을 처리할 수 없는 경우 발생하는 상태코드**
    
    - 구문적으로는 올바르지만 의미적으로 잘못된 경우
        
        ex) JSON 요청에 필수 필드가 누락된 경우 : 아이디와 비밀번호가 필요한 상황인데 비밀번화 필드만 받은 경우
        
    
- 426 Upgrade Required
    
    **→ 서버가 현재 프로토콜을 사용하여 요청을 수행하는 것을 거부하지만 다른 프로토콜로 업그레이드 한 후에 요청을 수행할 의향이 있는 것을 나타낸다.**
    
    - Upgrade header field를 사용하여 필요한 프로토콜을 표시할 수 있다.
        - Upgrade header field
            
            클라이언트와 서버 간의 HTTP 연결을 다른 프로토콜(WebSocket, HTTP/2, HTTP/3 )로 업그레이드하거나 전환하는 데 사용된다.
            
        

### 서버 에러 응답 (500 ~ 511)

→ 서버 사정으로 메세지 처리에 오류가 발생한 것을 말한다. (서버의 부하, DB 처리 과정 오류, 서버에서 익셉션)

- 오류 상황의 대한 설명과 일시적인지 영구적인지의 대한 상태 설명이 포함된 representation 을 보내주어야한다.

- 500 Internal Server Error
    
    **→ 서버가 요청을 처리할 수 없는 예기치 않은 상태가 발생했음을 나타낸다.**
    

- 501 Not Implemented
    
    **→ 서버가 요청을 처리하는데 필요한 기능을 지원하지 않는것을 나타낸다.**
    
    - 서버가 요청 메소드를 인식하지 못하고 리소스에 대해 해당 메소드를 지원할 수 없는 경우 보여지는 응답입니다.
    - 휴리스틱적으로 캐시 할 수 있다.
    
- 502 Bad Gateway
    
    → **서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 처리하려고 시도하는 동안 액세스한 인바운드 서버로 부터 잘못된 응답을 받은것을 나타낸다**. (클라이언트 - 서버 - 또 다른 인바운드 서버 구조)
    
    - 게이트웨이
        
         컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 컴퓨터나 소프트웨어를 두루 일컫는 용어
        
        - 네트워크 입장 : 해당 네트워크에서 다른 네트워크로 나가는 출구이며 다른 네트워크로 들어가는 입구
        - 데이터 입장 : 외부 네트워크로 나가거나 다른 네트워크로 들어갈때 반드시 지나가야 하는 통로
        - 호스트 입장 : 로컬 호스트들이 외부망 호스트 기기와 통신할때 반드시 도달해야할 접속 지점
    - 인바운드
        
        데이터가 서버 내부로 들어오는 것을 말한다.
        
    
- 503 Service Unavailable
    
    **→ 일시적인 과부하 또는 예정된 유지 관리로 인해 서버가 현재 요청을 처리할 수 없음을 나타낸다.(일시적인 지연후 완화 될 가능성이 높다)**
    
    - 서버는 요청을 재시도하기 전 클라이언트가 기다릴 수 있는 적절한 시간을 제안하기 위해 재시도 후 Retry-After header 필드를 보낼 수 있다.
        - Retry-After header 필드
            
            사용자(클라이언트) 측에게 후속 요청을 하기전 얼마나 기다려야 하는지 나타내 주는 헤더 필드 입니다.
            
        
- 504 Gateway Timeout
    
    **→ 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 액세스해야 하는 업스트림 서버로부터 적시에 응답을 받지 못했음을 나타냅니다.**
    
    - 업스트림 서버, 다운 스트림 서버
        - 다운 스트림 서버 : 가운데서 게이트웨이나 프록시 역할을 하는 서버
        - 업 스트림 서버 : 클라이언트 요청의 대한 원래 목적지 서버
    
- 505 HTTP Version Not Supported
    
    **→ 서버가 요청 메시지에 사용된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부한다는 것을 나타낸다.**
    
    - 서버는 해당 코드의 대해 해당 버전이 지원 되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 representation 을 생성해서 보내주어야한다.

### 질문

- 301 상태코드 와 308 상태코드의 차이??
- 302 상태코드 와 307 상태코드의 차이??