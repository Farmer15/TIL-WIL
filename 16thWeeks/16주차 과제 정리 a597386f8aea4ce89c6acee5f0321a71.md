# 16주차 과제 정리

- CORS 보충 정리
    - 서버측에서는 단순 요청이 오면 응답을 처리하고 브라우져에서 검사(CORS)를 진행한다
    - CORS 요청의 2가지 경우
        - 단순 요청
            - 요청 메서드가 GET, HEAD, POST 인 경우
            - 유저 에이전트가 수동으로 설정할 수 있는 헤더는 아래만 허용 됩니다.
                - Accept, Accept-Language, Content-Language, Content-Type
            - Content-Type 으로는 아래만 허용 됩니다.
                - application/x-www-form-urlencoded
                - multipart/form-data
                - text/plain
        - 프리플라이트 요청 (+ 실제 요청)
            - OPTIONS 메서드를 통해 다른 출처를 가진 리소스(다른 서버)에 미리 HTTP 요청을 보내 실제 요청을 보내도 안전한지 확인을 합니다.
        - 헤더 필드 정리
            - 요청측 헤더 필드
                - Origin
                    
                    → 요청이 시작된 서버를 나타내는 URI 를 나타냄 (서버 이름만 나옴, null 이 올수도 있다)
                    
                    ```jsx
                    origin: "http://localhost:3000/"
                    ```
                    
                - Access-Control-Request-Method
                    
                    → 실제 요청에서 어떤 HTTP 메서드를 사용할지 서버에게 알려준다.
                    
                    ```jsx
                    Access-Control-Request-Method: "GET", "PUT"...
                    ```
                    
                - Access-Control-Request-Headers
                    
                    → 실제 요청에서 어떤 HTTP 헤더를 사용할지 서버에게 알려준다.
                    
                    ```jsx
                    Access-Control-Request-Headers: "vaco",~~~ 
                    ```
                    
            - 응답측 헤더 필드
                - Access-Control-Allow-Origin
                    
                    → 해당 단일 출처를 등록하여 해당 출처에대해 리소스 접근을 허용하게 해준다.
                    
                    ```jsx
                    Access-Control-Allow-Origin: "http://localhost:3000"
                    ```
                    
                - Access-Control-Expose-Headers
                    
                    → 해당 헤더를 사용하면 브라우저가 접근할 수 있는 헤더를 서버의 화이트리스트에 추가할 수 있습니다.
                    
                - Access-Control-Max-Age
                    
                    → preflight request 요청 결과를 캐시할 수 있는 시간을 나타낸다.(초 단위)
                    
                    ```jsx
                    Access-Control-Max-Age: 1s, 2s 3s, ...
                    ```
                    
                - Access-Control-Allow-Credentials
                    
                    → credentials 플래그가 true 일때 요청에 대한 응답이 노출 될지에 여부를 나타내는 것을 말한다.
                    
                    - 쿠키를 포함한 요청을 보내고 싶다면 서버 응답에서 이 헤더로 응답을 받아야지만 클라이언트가 요청을 할 수 있다.
                - Access-Control-Allow-Methods
                ->해당 메서드들을 허용하겠다는 것을 나타냅니다.
                    
                    ```jsx
                    Access-Control-Allow-Methods: "GET", "POST", ...
                    ```
                    
                - Access-Control-Allow-Headers
                    
                    → 해당 헤더를 허용하는 것을 나타낸다.
                    
                    ```jsx
                    Access-Control-Allow-Headers: "vaco", "hello"...  
                    ```
                    
                    - 커스텀 헤더들을 허용해준다.
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled.png)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/ead293a3-729d-4cb8-b7d4-8d485d3bcdbc.png)
            
- 프로젝트 설계
    - 페이지 도안(청사진)
        - 투표페이지(”/votings/:id”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%201.png)
            
        - 로그인(”/login”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%202.png)
            
        - 회원가입(”signup”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%203.png)
            
        - 메인 화면(”/”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%204.png)
            
        - 투표 생성(”/voting/new”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%205.png)
            
        - 내 투표 목록(”/my-voting”)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%206.png)
            
        - 투표 성공(모달), 실패(모달)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%207.png)
            
    - 스키마 설계
        - 투표목록 배열: {
            
                   제목: 스트링 형식, 꼭 필요,
            
             유저이름: 유저닉네임: 유니크 지정(중복제거) 꼭 필요,
            
             투표 옵션들: [{
            
            내용: 스트링 형식, 꼭 필요,
            
            투표수: 숫자 형식, 기본값: 0,
            
              }],
            
             만료일: 만료일 꼭 필요,
             인덱스: true (자동정렬),
            
            ?? : {
                type : ObjectId 
                ref: “유저”
             }
            
        
               }
        
        - 유져정보 : {
            
                유져닉네임 : 스트링형식, 유니크 지정(중복제거), 꼭 필요,
            
                유져아이디 : 이메일 형식, 유니크 지정(중복제거) , 꼭 필요, 
            
                유져비밀번호 : 스트링+이메일 형식, 최소, 최대 몇글자 지정, 꼭 필요,
            
        
              }
        
- REST API, RESTful
    
    ### REST(Representational State Transfer) 란?
    
    → 분산 시스템을 위한 아키텍쳐 스타일로써 자원 관리 및 상호 작용에 대한 원칙과 제약 조건을 정의한다.
    
    - 처음에는 인터넷과 같은 복잡한 네트워크에서 통신을 관리하기 위한 지침으로 만들어짐
    
    ### REST 여러 조건들
    
    - 클라이언트-서버 구조로 서로 독립적으로 발전할 수 있다.
        - 클라이언트 : 사용자 인터페이스를 관리하고
        - 서버: 데이터 저장소와 비즈니스 로직을 관리
    - 계층형 시스템이 존재할 수도 있다.
        - 클라이언트와 - 서버 사이에 여러 계층으로 나뉘어서 각각의 계층이 독립적으로 여러 동작을 수행 할 수 있다 (로드 밸런싱, 캐시제어)
    - 각각의 요청은 Stateless 해야한다.
    - 다양한 형태로 클라이트와 서버 사이 데이터주고 받는다. (JSON, XML, HTML)
    - 응답에 대해 캐시 가능여부를 지정할 수 있어야한다.
    
    ### REST 장점
    
    - 단순성 : 일관된 인터페이스와 표준으로 HTTP 메서드를 활용하여 쉽게 이해하고 구현가능하다
    - 확장성 : 클라이언트와 서버가 독립적으로 동작하므로 확장 가능하고 유연하다.
    - 캐시 가능성 : HTTP의 캐싱 메커니즘을 활용하여 성능을 향상시킬 수 있다.
    
    ### REST API 란
    
    → REST 아키텍처 스타일을 따르는 API를 지칭한다.
    
    - 아키텍처란 ?
        - **아키텍처**란 : 시스템의 구성요소들 간의 관계와 원칙, 그들이 이루는 전반적인 구조를 정의하는 것
        - **아키텍처 스타일**이란 : 시스템의 구조를 정의하는 방법으로 시스템의 컴포넌트 간의 관계와 상호작용 방식을 규정하는 패턴이나 규칙
        
        - 여러가지 아키텍처 스타일
            - 레이어드 아키텍처
                - 시스템을 여러층으로 나누어 각 층이 특정 기능을 담당하도록 하는 방식
                - 일반적으로 프레젠테이션, 비즈니스 로직, 데이터 접근 층으로 나뉜다.
                - 각 층은 자신보다 상위 층에만 의존하도록 설계
            - 클라이언트-서버 아키텍쳐
                - 클라이언트와 서버 간의 요청-응답 패턴으로 구성된 구조
                - 클라이언트 : 사용자 인터페이스와 사용자 요청을 처리
                - 서버 : 데이터와 비즈니스 로직을 관리
            - 마이크로서비스 아키텍쳐
                - 시스템을 독립적으로 배포 및 운영할 수 있는 작은 서비스 단위로 분할하는 방식
                - 각 서비스는 독립적으로 개발되고 배포 될 수 있고 API 를 통해 통신한다.
            - 이벤트 드리븐 아키텍처
                - 이벤트 발생에 따라 시스템의 컴포넌트가 동작하는 방식으로
                - 이벤트 프로듀서가 이벤트를 발생시키고, 이벤트 컨슈머가 이를 처리하는것을 뜻함
            - 서비스 지향 아키텍처
                - 다양한 서비스들이 서로 통시하며, 서비스는 명확히 정의된 인터페이스를 통해 제공된다.
                - 주로 웹 서비스 프로토콜(REST, SOAP)을 사용한다.
            - 모놀로식 아키텍처
                - 하나의 통합된 코드베이스에서 모든 기능을 제공하는 것을 뜻한다.
                - 애플리케이션 모든 부분이 하나의 단일 애플리케이션으로 결합되어 배포된다.
    - API 란? (추후 보완 필요)
        
        Application Programming Interface로 서로 다른 여러 프로그램들, 데이터베이스, 기능들 끼리 통신하기 위해 따라야 하는 규칙을 정의한다.
        
        - 웹 API는 클라이언트와 웹 리소스 사이의 게이트웨이라고 생각할 수 있다.
            - 클라이언트 : 웹에서 정보를 액세스하는 사용자를 지칭한다.(사람이거나 소프트웨어 시스템일수도)
            - 리소스 : 다양한 애플리케이션이 클라이언트에게 제공하는 정보
    
    ### REST API 특징
    
    - 각각의 리소스는 URI를 통해 식별된다.
    - HTTP 메서드, 상태코드를 사용해서 소통합니다.
    - 표현 방식은 JSON, XML 등 표준화된 형식으로 클라리언트-서버 간 소통합니다.
    - 클라이언트, 서버가 독립되어 있어서 기술 또한 독립적으로 분리되어 있습니다.
    
    ### RESTful API 란?
    
    → REST 원칙을 잘 구현한 REST API 를 지칭하는 단어이다.
    
    ### RESTful API 특징
    
    - 모든 REST 원칙을 따른다.
    - 일관된 URI 구조를 사용해서 자원을 명확하게 식별가능하다.
    - HTTP 메서드를 사용해서 리소스에 대한 작업을 처리한다.
    - 각 요청이 Stateless 특징을 가진다.
    - 클라이언트와 서버를 명확히 구분한다.
    - 응답은 캐시가 가능하다.
- CSR, SSR
    
    ### CSR 이란
    
    클라이언트(사용자 브라우저)에서 렌더링이 수해되는 것을 뜻한다.
    
    ### CSR 작동방식
    
    - 사용자가 웹페이지를 요청하면 서버는 HTML 문서와 JavaScript 파일을 같이 전달합니다.
    - 브라우저는 HTML 문서와 JavaScript 파일을 로드한 후엔 JavaScript 가 클라이언트 측에서 페이지를 생성하고 렌더링을 진행합니다.
    - 이후 데이터는  API 호출을 통해 클라이언트 측에서 처리된다.
    
    ### CSR 장점
    
    - 페이지가 한번 로드 된 이후 페이지내에서 원활하게 상호작용이 이루어진다.
    - 페이지를 전환하는데 서버에 추가적인 요청없이 클라이언트 측에서 이루어지므로 빠르게 전환 될 수 있다.
    
    ### CSR 단점
    
    - 초기 로드 시 브라우저가 JavaScript을 다운로드 하고 실행시켜야 하므로 느려질 수 있다.
    - SEO 검색 엔진이 JavaScript을 올바르게 실행하지 못하는 경우 SEO가  제대로 작동하지 않을 수 있다.
    
    ### CSR 에서 javascript
    
    - 서버 측 javascript
        - 초기 HTML 파일과 함께 javascript 파일을 포함한 <script> 클라이언트에 전달해준다.
        - 클라이언트 애플리케이션이 데이터와 상호작용 할 수 있도록 REST API 또는 GraphQL API 를 제공해준다.
            
            → 이 API 를 통해서 클라이언트 측에서 데이터 요청을 처리한다.
            
        - 데이터베이스 연동, 사용자 인증, 비즈니스 로직를 담당하며 클라이언트 요청에 따라 필요한 데이터를 제공해준다.
    - 클라이언트 측 javascript
        - 서버에서 클라이언트 측에 제공된 HTML 페이지와 서버에서 제공된 javascript를 실행하여 애플리케이션 초기화를 시켜준다.
        - URL에 따라 페이지를 동적으로 바꿀때 라우팅을 처리하는 역할도 한다.
            
            → 동적 렌더링을 담당해서 부분적으로 업데이트 적용 (SPA)
            
        - URL 변경에 따라 동적으로 로드해 줌과 동시에 브라우저 히스토리
        - 모든 상태 관리, 사용자와 상호작용, 서버로부터 데이터를 받는 역할을 서버에서 받은 javascript로 수행합니다.
    
    ### SSR 이란
    
    → 서버에서 렌더링이 실행되는 것을 뜻합니다.
    
    ### SSR 작동방식
    
    - 클라이언트(사용자 브라우저)가 특정 URL 웹 페이지를 요청하면
    - 서버는 URL에 맞는 HTML 페이지를 생성합니다.
        - 생성할때 데이터베이스와 상호작용 또는 필요한 API를 호출하여 생성합니다.
    - 그렇게 완성된 HTML페이지를 렌더링해서 클라이언트가 받으면 바로 렌더링할 수 있는 상태로 만들어주고 클라이언트로 전송합니다.
    - 그렇게 받은 HTML을 클라이언트 측에서 렌더링하여 사용자가 볼 수 있도록 보여주고 이후 JavaScript 파일이 다운로드 되어 클라이언트 측의 추가적인 상호작용과 동적 기능을 처리합니다.
    
    ### SSR 장점
    
    - 이미 서버에서 렌더링 된 HTML을 제공 받기 때문에 브라우저는 즉시 페이지를 표시할 수 있어서 초기 로딩 속도가 빠릅니다.
    - 검색 엔진 크롤러가 서버에서 렌더링 된 HTML을 쉽게 인식하고 발견할 수 있어서 SEO에 유리합니다.
    - 서버에서 제공된 HTML을 렌더링 하므로 클라리언트측 JavaScript가 오류가 발생하거나 비활성화 된도 페이지를 볼 수 있습니다.
    
    ### SSR 단점
    
    - 서버에서 모든 페이지를 렌더링해서 줘야하므로 비중이 늘어 부하가 증가합니다
    - 페이지를 전환할 때마다 서버에 요청을 보내 페이지를 받아야하므로 페이지 전환 속도가 느릴 수 있습니다.
    - 클라이언트 측에서 따로 JavaScript를 사용하여 동적 기능을 추가해주어야 합니다.
    - 페이지 전환에 있어서 페이지간의 정보 상태 유지하는데 어려움이 있을 수 있습니다.
    
    ### SSR javascript 역할
    
    - 서버측 javascript
        - SSR을 담당해서 요청에 대한 HTML 페이지를 만들어줍니다.
        - 제일 처음 필요한 초기 데이터를 포함시켜서 전송해줍니다.
        - API 를 제공해서 초기 렌더링 후에도 클라리언트 측에서 API 를 통해 추가 데이터를 불러 올 수 있습니다.
    - 클라이언트 측 javascript
        - 하이드레이션이라는 서버에서 받은 정적 HTML 페이지을 클라이언트 측에서 이벤트 핸들러와 동적기능을 추가하는 과정을 거쳐 최종 HTML 을 완성합니다.
        - 비동기 데이터를 요청해서 추가로 페이지를 업데이트는 하는데 도움을 줍니다.
- SPA, MPA
    
    ### SPA 란
    
    → Single Page Application 으로 단일 페이지에서 동적으로 업데이트 되는 웹 애플리케이션 아키텍처를 중 하나이다. 
    
    ### SPA 특징
    
    - 전체 페이지가 새로고침 되지 않고 필요한 데이터에 대해서만 서버로 부터 받아와서 동적으로 변경합니다.
    - 하나의 페이지 내에서 URL을 이용해 동적으로 변하므로 해당 URL 상태를 브라우저가 히스토리에 저장하게 된다.
    - CSR 사용하기 때문에 해당 장단점이 그대로 따라온다.
    
    ### MPA란
    
    Multi Page Application 으로 사용자에게 다수의 HTML 페이지를 제공하는 구조를 가진 웹 애플리케이션 아키텍처 중 하나이다.
    
    ### MPA 특징
    
    - 여러 개의 독립적인 HTML로 페이지가 구성됩니다.
    - SSR을 사용하기 때문에 해당 장단점이 그래로 따라옵니다.
    - Javascript 에 크게 의존하지 않기 때문에 여러 브라우저에 호환이 가능합니다.
    - 서버에서 페이지들을 처리하기 때문에 보안 문제를 줄일 수 있습니다.
- 번들링, 번들러
    
    ### 번들링
    
    HTML, CSS, JS 등의 모듈화 된 자원들을 모아서 배포에 최적화된 하나 혹은 최적의 소수 파일로 결합하는 것을 뜻한다.
    
    ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%208.png)
    
    ### 번들링의 장점,버들링이 필요한 이유
    
    - 웹 페이지를 로드하는데 필요한 HTTP 요청 횟수를 줄여 지연 시간을 최소화하여 성능을 향상시킵니다.
    - 축소(minification), 트리세이킹(tree shaking), 코드 분할(code splitting)을 이용해서 파일 크기를 줄이고 로드 시간(지연 시간) 을 개선시켜줍니다.
        - 축소 (minification)
            
            →웹 페이지와 스크립트 파일에서 코드와 마크업을 최소화하는 프로세스
            
            ### minification 필요한 이유
            
            파일을 만들때 개발자는 코드와 마크업을 읽을 수 있도록 띄어쓰기, 주석, 잘 명명된 변수를 사용하는데
            
            이러한 과정은 나중 다른 사람이나 개발단계에선 큰 도움을 주지만
            
            웹 서버나 브라우저 측면에서 파일을 파싱하는데 있어서는 기능적이점 없이 추가적인 네트워크 트래픽을 발생시키기 때문에
            
            코드를 최소화하고 주석과 공백을 제거해야하며 변수 이름을 크런치(더 짧고 간다하게 바꿈)시켜야 한다.
            
        - 트리세이킹(tree shaking)
            
            빌드 과정에서 죽은 코드(사용하지 않는 코드)를 제거하는 것을 의미한다.
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%209.png)
            
            ![Untitled](16%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a597386f8aea4ce89c6acee5f0321a71/Untitled%2010.png)
            
        - 코드 분할(code splitting)
            
            애플리케이션의 전체 코드를 작은 청크로 분리하고 필요할때 해당 청크만 불러와서 사용하는 것을 뜻한다.
            
            ### 코드 분할(code splitting)의 목적
            
            CSR 에서 첫 로드시 많은 코드나 파일이 필요한데 코드 분할(code splitting)을 이용해 필요한 청크만 로드해서 보여줌(Lazy Loading)으로써
            
            - 쉽게 캐시될 수 있고
            - 첫 로드화면 로딩속도를 개선할 수 있고
            - 효율적으로 리소스들을 관리 할 수 있습니다.
    - 번들링을 함으로써 배포가 가능해져서 배포 가능의 대한 이점이 생긴다.
    - 최신 기능 (ES6, TypeScript, JSX, SCSS…)등을 사용할 수 있게 해주어서 오래된 브라우저에서도 호환 될 수 있게 해줍니다. (Babel 이나 다른 트랜스파일러를 같이 이용)
    - 코드를 더 작은 청크로 분할하여 필요에 따라 로드 할 수 있으므로 웹 애플리케이션의 확장성과 유지 보수가 용이해집니다.
    - 종속성, 버전 관리를 간소화시켜주면서 린팅, 테스트, 디버깅 같은 작업을 자동화 시킬 수 있다.
        - 종속성 관리: 코드의 종속성을 관리를 해줘서 올바른 순서로 로드될 수 있게 해줍니다.(각 모듈(import, require)을 분석하여 자동으로 추적해줌)
    
    —> 정리하면 코드와 에셋을 일관성있고 최신 상태로 유지해주면서 시간, 노력, 자원을 아끼는데 도움을 준다. 
    
    ### 번들러
    
    번들링을 자동으로 해주도록 도와주는 도구를 말한다.
    
    - Webpack
        - 자바스크립트 파일 뿐만 아니라 CSS, 이미지, 폰트등 다양한 리소스를 모듈로 취급하여 번들링할 수 있게 해줍니다.
        - 내부적으로 플러그인과 로더 시스템을 통해 확장성과 유연성을 제공하며
        - 축소(minification), 트리세이킹(tree shaking), 코드 분할(code splitting) 고급 최적화 기능을 제공해줍니다.
    - Rollup
        - 주로 라이브러리 번들링에 자주 사용되며 ES6 모듈을 기본적으로 하여 모듈화된 코드를 효율적으로 결합시켜줍니다.
    - Parcel
        - 설정이 거의 필요없는 번들러로써 빠른 빌드의 속도와 사용 편의성을 강조한다.
        - 기본 설정으로 다양한 파일 형식을 지원하며 추가 설정없이 복잡한 프로젝트를 번들링 할 수 있다.
    - Browserify
        - 초기 자바스크립트 번들러로 CommonJS 모듈을 브라우저 환경에서 사용할 수 있게 해줍니다.
        - node.js 스타일 모듈을 클라이언트 측 코드에서 사용할 수 있게 되었다.
    
    ### 자바 스크립트에서 번들러가 나오게 된 배경
    
    웹 애플리케이션이 복잡해지고 SPA이 등장하게 되면서 한번의 페이지로드에 많은 자바스크립트 파일이 필요하게 됨으로써 파일 관리와 로딩 효율성이 대두 되게 되었다.
    
    그렇게 “모듈” 이라는 개념이 나오고 Node.js 가 나오게 되면서 자바스크립트로 외부환경에서 파일을 다룰수 있게 되었고 그렇게 node.js 를 기반 여러 번들러들이 나오게 되었습니다.
    
    → 즉 프로트엔드 개발 환경의 진화 (CSR, SPA 등)와 모듈 시스템 도입, node.js 탄생, 개발 및 배포 환경의 변화, 웹 성능 최적화 필요 등등 에 의해 나오게 되었다!
    
    ### Node.js 와 번들러와의 관계
    
    - 기본적으로 Node.js는 번들러에게 동작하는 런타임 환경을 제공해줍니다.
    - Babel 이라는 트랜스파일러가 Node.js 환경에서 실행되므로 번들러 도구들과 통합되어 번들링과 트랜스파일링하는 작업이 함께 수행될 수 있다.
    - Node.js개발 서버를 쉽게 설정할 수 있는 환경을 제공해서 HMR 이라는 개발중 코드 변경시 페이지 전체를 새로고침하지 않고도 변경되 모듈만 업데이트 할 수 있도록 해준다. (webpack기능)
    - Node.js NPM 스크립트를 통해 다양한 빌드 프로세스를 자동화 할 수 있다.
- 모듈
    
    → 프로그램을 구성하는 요소로 관련된 데이터와 함수를 하나로 묶은 단위를 뜻함(분리된 파일을 각각)
    
    ### 모듈의 특징
    
    - 이러한 모듈을 합쳐 하나의 파일로 작성하는 방식으로 프로그램을 만든다.
    - 독립된 파일에 저장하여 관리하는 방식을 모듈화 프로그래밍이라고 한다.
    - 일반적으로 클래스 하나 또는 특정 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성됩니다.
    
    ### 모듈의 역사
    
    → 예전엔 애플리케이션이 작고 자바스크립트의 HTML 파일을 단순 스크립트로 연결시켜서 사용했는데 점차 스크립트가 커지고 기능도 복잡해짐에 따라 전체 파일이나 시스템을 작게 나누어서 관리 할 필요성을 느껴서 나오게 되었습니다.
    
    - 여러 개의 모듈 시스템이 나오게 되었는데
        - AMD
            - 브라우저 환경에서 비동기적으로 모듈을 로드하기 위해 설계된 모듈 시스템입니다.
            - 가장 오래된 모듈 시스템중 하나로 require.js 라는 라이브러리를 통해 처음 개발
        - Common JS
            - Node.js 에서 사용되는 모듈 시스템으로 require, module.exports 을 사용하여 정의하고 로드할 수 있게 도와줍니다.
        - UMD
            - AMD 와 CommonJS 와 같은 다양한 모듈 시스템을 함께 사용하기 위해 만들어졌다.
    - 위에 AMD, CommonJS, UMD 전부 요새는 잘 사용하지 않고 Node.js 가 모듈 시스템을 지원해준다.
    
    ### 모듈의 장점
    
    - 작은 독립적인 단위로 나누어 관리하기 때문에 복잡한 시스템을 관리할 때 편합니다.
    - 각각의 함수나 시스템이 독립적으로 분리 되어 있어서 다른곳에서 재사용 될 수 있습니다.
    - 수정을 해야할 일이 있거나 확장해야 할이 있을때 유지보수가 용이합니다.
    - 다른 팀원들과 협업 할때도 모듈화된 시스템을 독립적으로 개발할 수 있다 보니 협업하기 수월 할 수 있습니다.
    - 각각의 모듈들이 명확한 목적과 기능을 가지므로 가독성 적인 측면에서도 도움을 줍니다.
    - 작은 독립적인 기능들로 나누어져 있다보니 테스트 하기 수월합니다.
    
    ### 모듈 사용예시
    
    ```jsx
    export function sayHi() {
      console.log("hihi");
    }
    
    ---------------------------------------------------------------------------
    import { sayhi } from "해당경로";
    
    sayhi() // "hihi" 출력
    ```
    
    ### 모듈 vs 컴포넌트
    
    |  | 컴포넌트 | 모듈 |
    | --- | --- | --- |
    | 범위, 사용 맥락 | 더 큰 시스템의 독립적이고 재사용 가능한 부분을 의미 사용자 인터페이스, 비즈니스 로직등 특정 기능을 수행  | 주로 코듸의 논리적 그룹화를 의미해서 함수, 클래스, 변수 등을 포함하는 작은 단위 |
    | 독립성과 배포 | 독립적으로 배포되고 자체적인 라이프 사이클을 가진다. 
    컴포넌트 라이프 사이클 : 브라우저에 나타나고, 업데이트 되고, 사라지게 되는 과정 | 독립적으로 개발,재사용이 가능하지만 배포되지는 않는다. |
    | 사용 목적 | 시스템의 특정 기능을 독립적으로 구현, 재상용성과 유연성을 높이기 위해 사용됩니다. | 조직화와 재사용성을 높이기 위해 사용된다. |
- 웹소켓(webSockets)
    
    단일 TCP 연결을 통해 전 이중 통신을 제공하는 통신 프로토콜입니다.
    
    → 클라이언트와 서버간의 실시간 이벤트 기반 연결을 가능게 해줍니다.
    
    → 요청 응답을 따르는 기존 HTTP 와는 달리 양방향 소통을 허용한다.
    
    → 클라이언트와 서버는 지속적인 폴링없이 서로에게 데이터를 전송할 수 있다.