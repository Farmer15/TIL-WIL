# 17주차 과제 정리

- 프록시 서버
    
    ### 프록시 서버
    
    → 리소스를 요청하는 클라이언트와 리소스를 응답하는 서버 사이의 중개자 역할로 익명으로 데이터를 전달하는 게이트웨이를 말합니다(컴퓨터 시스템 또는 라우터 일 수 있습니다.)
    
    ### 프록시 서버 목적
    
    - 클라이어트와 서버간의 직접적인 직접 연결 보호
        
        ![Untitled](17%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A6%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20851a940c5a0549fdad7241536e900631/Untitled.png)
        
    
    ### 프록시 서버 장점
    
    - 보안 향상
        
        악성 데이터가 서버에 도달하기 전에 필터링 가능해서 보안 계층 역할을 할 수 있다.
        
    - 캐싱 가능
        
        자주 방문하는 사이트는 프록시에 의해 캐시 가능하므로 같은 요청에대해 서버에 요청을 보내지 않고 캐시 되어 있는 값을 사용한다.
        
    - 인터넷 사용제어
        
        원치 않은 콘텐츠를 차단하여 직원들 사이트에 제한을 둘 수 있다.
        
    - 제한 사항 우회
        
        CORS 나 특정 IP 만 접속 가능할때 사용해서 우회 할 수 있다.
        
    - 사행활 보호
        
        클라이언트 측 IP 주소를 숨겨줍니다.
        
    - 트랙팩 제어
- AJAX (**A**synchronous **J**avaScript **A**nd **X**ML)
    
    클라이언트 측에서 다양한 웹 기술을 사용하여 비동기 웹을 만드는 웹 개발 기술 세트를 말합니다.
    
    ### AJAX 특징
    
    - 비동기적으로 이루어지기 때문에 기존 페이지의 표시 및 동작을 방해하지 않습니다.
    - 웹 애플리케이션이 전체 페이지를 다시 로드할 필요 없이 컨텐츠를 동적으로 변경할 수 있도록 해줍니다.
    - 필요한 데이터만 주고 받기 때문에 네트워크 트래픽을 줄이고, 서버 응답 시간을 단축 시킬 수 있다.
    
    ### AJAX 역사
    
    1990 년대 초중반에 대부분 웹사이트가 HTML 기반으로 만들어졌고
    
    부분적인 변경으로 브라우저가 페이지를 다시 로드 할 때마다 일부 정보만 바뀌어도 모든 컨텐츠를 다시 보내야 합니다.
    
    이로 인해 서버에 추가 부하가 발생하고 대역폭이 성능을 제한하는 요인이 발생했습니다.
    
    1996 년에 iframe 태그가 나오면서 비동기 통신 개념이 등장하게 되었다
    
    Microsoft에서 XMLHTTP을 도입함으로써 JavaScript가 비동기적으로 통신할 수 있는 방법을 제시하게 되었습니다.
    
    그렇게 2000년대 중후반에 AJAX를 기능을 쉽게 사용하게 해주는 다양한 라이브러리와 프레임워크(jQuery)가 나오게 되었고 HTML5 표준화 과정에서 XMLHttpRequest 객체는 더 많은 기능을 갖추게 되었습니다.
    
    ### AJAX 구성
    
    - 정보를 표시하기 위한 XHTML 및 CSS
        - XHTML
            
            EXtensible(확장가능) HyperText Markup Language 로 HTML 과 XML 의 교차점을 나타낸다. 
            
            ### XHTML특징
            
            - HTML 과 거의 동일 하지만 보다 엄격하다.
            - 엄격하게 설계 된 XML 로 설계된  HTML을 뜻한다.
            - 모든 주용 브라우저에서 지원가능
            - XHTML 코드는 HTML 규칙을 따르지 않더라도, 대부분의 브라우저에서 제대로 작동합니다.
            
            ### XHTML사용 이유
            
            - HTML의 사용성을 높이고 다른 데이터 형식 과의 상호 운영성을 높이기 위해 개발
            - 변경 없이 다양한 장치에서 사용할 수 있는 표준을 만든다.
    - 데이터 교환 및 조작을 위한 XML, HTML, XSLT
        - XML
            
            모든 데이터를 정의하는 규칙을 제공하는 마크업 언어 저장과 전송을 위해 설계된 마크업 언어입니다.
            
            ### XML 특징
            
            - 사용자가 자신만에 태그를 정의 할 수 있다.
            - 다른 언어와 달리 자체적으로 컴퓨팅 작업을 수행 할 수 없다.
            - 구조적 데이터 관리를 위해 모든 프로그래밍 언어 또는 소프트웨어 구현할 수 있다
            - HTML 과 유사하지만 미리 정의된 태그가 없는 마크업 언어이다.
            - 기본 형식이 표준화 되어 있어서 로컬 또는 인터넷을 통해 여러 시스템이나 플랫폼에 XML 을 공유해도 데이터를 파싱 할 수 있습니다.
            - XML은 계층적 구조를 표현할 수 있어서 데이터 관계를 명확하게 정의할 수 있습니다.
            - 컴퓨터가 자연어를 보다 효율적으로 해석 할 수 있게 해준다
            
            ### XML 장점
            
            - 검색 엔진과 같은 프로그램에서 더 효율적이고 정확하게 XML 파일을 정렬하고 분류 할 수 있다.
            
            ### XML 예시
            
            ```jsx
            <myNote>
              <myName>hihi</myName>
              <email>hoho@@naver.com</email>
              <phone>01012345678</phone>
            </myNote>
            ```
            
    - 동적으로 상호작용하고 표시하기 위한 DOM
    - XMLHttpRequest 객체를 이용해 비동기적으로 조작
    - 바인딩을 위한 JavaScript 데이터 요청 및 정보표시
- Fetch
    
    XMLHttpRequest 을 대신하는 최신 버전으로 콜백을 사용하는 XMLHttpRequest 달리 promise 기반으로 사용되는 API를 지칭한다.
    
    ### Fetch 특징
    
    - promise 기반으로 작업을 처리한다 (반환값도 프로미스 이다)
    - 문법이 단순하고 직관적입니다.
    - 에러처리 할 때 간편하게 할 수 있습니다.
        
        → .then , .catch 또는 async/await 와 결합하여 에러처리 가능하다.
        
    
    ### Fetch 함수
    
    - 첫 번째 매개변수 : URL or Request객체
    - 두 번째 매개변수 : options 를 제공해준다.
        - 메서드 설정 : “GET”,  “POST”, “DELETE”, “PATCH”
        - 헤더 설정 : “Content-Type”, “Authorization”
        - 바디 설정 : FormData 객체, 일반 텍스트 문자열, JSON 객체
        - 캐싱처리 : 브라우저가 응답의 캐싱을 처리하는 방법을 지정
    - 반환 받은 Request 처리
        - response.json() : JSON으로 구문 분석 JavaScript로 객체로 확인되는 promise를 반환시켜줍니다.
        - response.text() : 일반 텍스트로 확인되는 promise를 반환
        - response.blob() : 응답 본문을 나타내는 blob 객체로 확인 되는 promise를 반환합니다.
            - blob 객체
                
                주로 파일처리나 이미지 미리보기, AJAX 요청에 사용되어서 이진 데이터를 저장하는 데이터 형식을 지칭한다. 
                
                ### Blob 객체 특징
                
                - 이진 데이터 저장가능 : 텍스트, 이미지, 비디오, 오디오 같은 다양한 종류의 이진 데이터를 저장 할 수 있습니다.
                - 대용량 데이터 처리가능 : 파일이나 데이터 스트림 처럼 크기가 큰 데이터를 저장 할 수 있다.
                - 유연한 데이터 타입 : 다양한 MIME 타입을 지원하여 여러 형식의 데이터를 저장 할 수 있다.
                    - MIME 란(보완 필요)
                        
                        **M**ultipurpose **I**nternet **M**ail **E**xtensions 이메일 프로토콜의 확장으로 이메일을 통해 ASCII 텍스트와 ASCII 가 아닌 데이터를 모두 내보낼 수 있다.
                        
                        ### MIME 장점
                        
                        - 이메일을 통해 다양한 종류의 바이너리 첨부 파일을 보낼 수 있다.
                        - 서로 다른 유형의 여러 첨부 파일을 같은 이메일에 포함 시킬 수 있습니다.
                        - 메세지 길이에는 제한이 없습니다.
                        - 
                - 편리한 인터페이스를 제공 : JavaScript에서 쉽게 생성, 조작, 전송할 수 있는 인터페이스를 제공해줍니다.
        - response.arrayBuffer() : Array Buffer 로 확인되는 객체를 반환합니다.
            - Array Buffer란? (보충 필요)
                
                javaScript에서 바이너리 데이터를 다루기 위한 객체로 고정 길이의 원시 이진 데이터 버퍼를 나타낸다.(바이트 배열이라고 불린다.
                
                ### Array Buffer 특징
                
                - Array Buffer는 생성 시 지정된 길이, 고정된 크기를 가지며 생성된 후에는 크기를 변경할 수 없다.
                - 이진 데이터를 저장할 수 있다.
                - TypedArray 나 DataView객체를 사용해 데이터를 읽고 쓸 수 있다.
                
    
    ### 사용 예시
    
    ```jsx
    const response = await fetch("localhost:3000", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        title: "foo",
        body: "bar",
        userId: 1,
      });
    
    const result = await response.json();
    ```
    
- Axios
    
    웹 브라우져 또는 Node.js 에서 HTTP 요청을 하는데 사용되는 인기 JavaScript 라이브러리로 브라우저에서 XMLHttpRequests를 만드는데 사용됩니다.
    
    - 서버 측에서는 http 모듈을 사용하고 클라이언트 에서는 XMLHttpRequests를 사용합니다.
    - promise 와 콜백 모두 지원합니다.
    
    ### Axios vs Fetch
    
    | Axios  | Fetch |
    | --- | --- |
    | 요청 객체에 url이 있습니다. | 요청 객체에 url이 없습니다. |
    | 쉽게 설치할 수 있는 독립형 타사 패키지 입니다.  | 대부분 최신 브라우저에 내장되어 있습니다. |
    | XSRF 보호 기능이 내장되어 있습니다.  | XSRF 보호 기능이 있지 않습니다. |
    | data 속성을 사용합니다. | body속성을 사용합니다. |
    | Axios 데이터에는 객체가 포함되어 있습니다.  | Fetch의 본문은 문자열화 되어야 합니다.  |
    | 상태가 200이고 statusText OK 일 때 정상 처리입니다. | 응답객체에 ok 속성이 포함된 경우 정상 처리 입니다. |
    | JSON 데이터의 자동 변환을 수행합니다. | JSON 데이터를 처리할 때 먼저 실제 요청에서 .json을 호출해야 합니다. |
    | HTTP 요청을 가로챌 수 있습니다. | 요청을 가로채는 방법을 제공하지 않지 않습니다. |
    | 다운로드 진행 상황에 대한 지원이 내장되어 있습니다. | 업로드 진행률을 지원하지 않습니다. |
    | 광범위한 브라우저 지원을 제공합니다. | 특정 브라우저만 지원합니다. |
    | 데이터 콘텐츠를 무시합니다. | 호출 페치에는 본문 내용이 있을 수 있습니다. |
    |  |  |
    - 요청 객체에는 url이 있다.
    - 쉽게 설치할 수 있는 타사 패키지입니다.
    - XSRF 보호 기능이 내장되어 있습니다.
    - Axios 데이터에는 객체가 포함되어 있습니다.
    - 상태가 200이고 statusText 가 OK 일 때 Axios 요청은 정상입니다.
    - JSON 데이터의 자동 변환을 수행합니다.
    - 요청 및 요청 시간 초과를 취소할 수 있습니다.
    - HTTP 요청을 가로챌 수 있습니다.
    - 
    
- 동적 알고리즘(기억하기)
    - 여러 조합을 탐색해야만 하는경우 시간복잡도를 낮추기 위해 고안
    - 메모리를 사용해서 중복연산을 줄여줍니다.
        - 어떤 형태로든 자료구조에 이미 도출된 결과값을 저장해 두었다가 나중에 같은 연산을 시행시 저장해둔 결과값을 이용해서 결과를 도출하는 방법
    - 관계식을 잡아내는게 핵심
    
    ### 사용될때
    
    - DFS/BFS 로 풀수는 있지만모든 경우를 고려해야 하는경우
    - 중복 연산이 발생한다고 판단이 되는 경우
    - 최적의 답을 찾아야하는 문제(optimization problem)
    
    - 어떤 정보를 담아야 뒤로 돌아가지 않을까 ?